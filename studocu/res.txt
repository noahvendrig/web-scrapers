 Download
Save
SDD HSC Full Notes
Course:
Software Design and Development (Year 12 - Unit 4)
Determining user needs about their work routine assist in the user interface design which 
allows users to work efficiently including consistency of elements, colour, fonts and 
alignment properly. User testing is used to evaluate the ergonomic design of software.
Inclusivity Issues
Responsibility to ensure software is accessible to anyone regardless of their differences 
including cultural differences, economic market, gender and disability.
Privacy
Users have the right to know if their information is being held. Some organisations need to 
legitimately access sensitive information and therefore users are protected under the 
Privacy Act 1988.
Software Piracy and Copyright
Illegal copying and use of software. Occurs when intellectual property rights of the 
developer are infringed. Software piracy results in the increase in the cost of software for 
those who follow ethical standards and reduce user options as software developers have 
reduced incentive to develop new ideas.
Intellectual property is personal ownership of the creative ideas that develop from an 
individual’s mind or intellect. Includes patents, trademarks, trade secrets and confidential 
business information.
Plagiarism is appropriating or imitating someone’s ideas and manner of expressing them 
and claiming them as your own. Plagiarism in software is ambiguous and to avoid infringing 
another person’s intellectual property and sources should be acknowledged and 
compensated.
Copyright Laws
Purpose of these laws is to provide economic incentives for creative activity. Copyright 
protects the expression of ideas rather than the ideas themselves. They give the owner the 
sole right to reproduce their own work. Copyright Amendment Act 2006. Lasts for 70 years.
Classification of software
Commercial
-Purchasing licence to use software
-Licensing company owns product and copyright
-Software covered by copyright
-One archival copy can be made
-Reverse engineering and de-compilation not allowed
Open Source
Place
-An audience must be specified before deciding on a place to sell the product
-There are many methods of distributing software; shop fronts, online, bookstores.
-Depending on where the software is sold, it can change the perception of customer’s 
expectations
Price
-A developer has a responsibility to arrange a reasonable price for a product
-Methods for pricing a product are either a cost-plus basis, or consumer-based pricing
Promotion
-The different ways developers use to persuade people to buy products
-Developers have an ethical responsibility in what they say about their product to their
consumers
-Promotion should help customers make informed choices
-Information cannot be misleading
-Word of mouth is a very powerful promotional tool for software.
Impact of new developers and software products
New software breakthroughs are usually inventions of new thinking and therefore boom. 
New products will pop up to try and innovate against the existing product, but unless it 
provides a huge advantage, the consumer is more likely to stick with the original default 
software product.
Legal Implications
National Legal Action
RACV vs Unisys 
Claims management system  electronic storage and retrieval system
Failed expectations of software. RACV sought damages citing false representation and 
misleading conduct. Awarded damages of $4 million dollars to RACV  
Microsoft vs Apple
Microsoft released windows after Apple released Macintosh. Both systems were distributed 
before legal action was taken. A settlement was reached allowing both companies to 
distribute their OS.
 Software Development Approaches
Factors of defining approaches
-Scale of the product
-Complexity of the product
-Skills of the personnel developing the product
-Detail of the requirements
-Time for project
-Budget
5 software approaches:
-Structured
-Agile
-Rapid application development
-Prototyping
-End user
Each software development approach consists of the same stages continually repeated, but 
with the frequency and timing unique to each development cycle.
5 stages include:
-Defining and understanding the problem
-Planning and designing
-Implementation
-Testing and evaluating
-Maintenance
Structured Approach
-Time consuming, ordered and controlled
-Highest level of personnel skill required
-Product of highest size and quality
-Top down approach (waterfall method)
-Thoroughly planned, documented and monitored
-Used for large products in large companies
-Costs are high and errors can be hard to find and correct
-Requirements are understood before design and coding occurs
-Requires high project management
Use of CASE tools
-Computer aided software engineering
-Use of computer assisted method to organise and control development of software, 
especially on large complex projects
-Using CASE allows designers, code writers, testers, planners and managers to share a 
common view of where a project stands at each stage of development
-CASE tool may portray progress graphically and may be linked to the documentation
-Supports specific tasks in software development lifecycle:
oBusiness and Analysis modelling
oDevelopment – design and construction
oVerification and validation – analyse code and specifications for accuracy
oConfiguration management – control check in and out of repository objects
oMetrics and measurement – analyse code for complexity, modularity, 
performance
oProject management - manage project plans, task assignments, scheduling
-Another common way to distinguish CASE tools is the distinction between Upper 
CASE and Lower CASE
oUpper – support business and analysis modelling, they support traditional 
diagrammatic languages such as ER diagrams, Data Flow diagram, structure 
charts, decision trees, decision tables
oLower – support development activities such as physical design, debugging, 
construction, testing, component integration, maintenance and reverse 
engineering
-CASE tools are used in following stages
oSoftware version control – as software is improved it becomes more difficult to 
keep track of versions (1.0, 2.0)
oTest data generation 
Test correct operation of modules
Test and evaluate performance
Check error messages
Outputs can be compared
oProduction of documentation
Avoid delays in production
Data flow diagrams
Structure diagrams
Flow charts
oProduction of code
Methods of installation of new or updated systems
Typically there involves a conversion from an old system to the new system. There are four 
typically methods of installation or conversion:
1. Parallel conversion
2. Pilot conversion
3. Phased conversion
4. Direct cut over
Direct Cut-Over 
-Involves the old system being completely dropped and new system being installed at 
the same time
-Need to make sure the new system is completely functional and operational
-This conversion method is only used when it is not feasible to operate two separate 
systems at the same time
-Any data conversion and import must be done before installation occurs
-New data lost if new system fails
-Implementation occurs over shorter period but may be more time consuming
Parallel 
-Involve the operating of both systems being run for a period of tome
-Allows problems with new system to be found without loss of data
-Once new system is up and running, the old system can stop being used
-Old systems must be used until conversion
Phased
-Gradual introduction of the new and discarding of the old
-Done by introducing new parts while removing old parts
-Often used when product is still under development
-Over time
Pilot
-New system installed for small number of users
-User learn use and evaluate new system
-Once it seen as satisfactory it is installed and used by all
-Allows users to become experts and teacher of the new system
-Pilot conversion also allows for testing of product in an operational setting
Employment trends in software development
-Large increase 1995  2000, employment continues to grow, albeit slower pace
-Employment based on experience
-Meet demand of jobs
-Outsourcing 
oOutsource work to specialists if they do not have expertise or resources
oTo reduce and control costs
oHigher quality results from specialists
oAccess to new tech 
oFaster development times
oSpecialists respond to change
-Contract programmers
oShort term to write specific software products
oCommon for analysts and programmers to change employers as they seek new 
contracts
Trends in software development
-Mobile application
-Big data processing – data analysts
-Cloud technology – iCloud, drop box; cloud security
-DevOPs software – development operation managers – serve customer and clients 
better; cloud management
-User interface developers- consumer focused, intuitive, create enterprise applications
and apps make it user friendly
-Web based software – google apps, Facebook, YouTube Instagram
-Learning objects
-Widgets
-Cloud computing
-Mobile tech
Defining and Understanding the Problem
Identifying the problem
-Carried out by a system analyst
-Includes following aspects
oNeeds of the client
Functionality
Compatibility
Performance
oDetermining the objectives which will be met
oBoundaries and scope of the problem is understood
-Understanding the problem will enable a better understanding of the inputs, 
processing and outputs of the system to be developed
-Software that is used to store and access sensitive information will need to include 
safeguards against unauthorised access
Customisation of existing software products
-Cost effective strategy for obtaining new functionality
-Many software developers spend much of their time modifying their own existing 
products to suit specific needs of individual clients
-Open source software is often customised to add new features; in many cases the 
modifications are built as add-ons which are then available to other users of the base 
software product
-The ability to customise software helps the original developer of the product widen 
their market
-It is common for tools to be included in many commercial products which allows the 
user to create customised screens and other functionality using wizards and multiple 
drag and drop design screens.
Cost effectiveness
-One of the constraints of a new software system will be that it falls within a certain 
budget. If it is not a requirement, then it will most likely be a constraint
-Compare the costs between developing a new product or modifying an existing 
product
-Development hardware costs
oAny new hardware that needs to be bought/leased to enable development
-Development software costs
oWhat software is required; programming languages, CASE tools, database 
managements systems, graphics tools
-Development personnel costs
oSalaries of development team and other staff
-Outsourcing costs
A budget for the development project needs to be decided about a range of factors 
including:
-Available capital
-Predicted sales of finished product
-Cost savings as a result of the products implementation
-Predicted future upgrade and maintenance costs for the product
-Ongoing consumer support costs
Selecting appropriate development approach
-Selecting an appropriate development approach if there is no appropriate existing 
solution is completed by understanding the requirements and specifications of the 
problem
-The nature and type of problem will also affect the development approach and 
programming paradigm to be used.
Design Specifications
Specifications of proposed system
-A software requirements specification is a standard framework for a team to develop 
a large, complex software system and includes a complete description of the 
behaviour of a system to be developed. 
-Includes a set of use cases that describes all the interactions the users will have with 
the software.
-SRS also contains non-functional requirements, and the methods which will be used 
to model the system will also be specified. 
Developers perspective
-Data types 
-Data structures and variables
oVariables represent storage locations of data within the computer system
oA programmer will look at the data items and determine how they are to be 
stored and accessed
oThe data type and an appropriate identifier is then determined
oMeaningful variable names are considered intrinsic documentation and help 
programmers follow the logic of the program
oGlobal or Local Variables
-Algorithms
oPseudocode or flow charts
oProblem is modularised
oTop down decomposition
oFamiliar modules which can be drawn from a library of code
oThis method ensures a minimum of testing is required
-Quality assurance
-Documentation
-Design approach
Users Perspective
-Interface design
-Social and ethical issues
-Relevance to user’s environment and computer configuration
Specifications developed from the user’s point of view should include and design 
specifications that influence the experience of the end user.
Standards for interface design will be specified to ensure continuity of design across the 
project’s screens. The wording of messages, design of icons and the format of any data 
presented to the user need to be determined and a set of specifications created.
- Ergonomic Issues should also be considered
-User’s existing computer environment will influence specifications created.
oIf users are familiar with existing applications, then some design elements 
should be incorporated in new solution so transfer of skills can take place
-Operating system settings and consideration of hardware necessary to execute new 
development
oModels will assist in determining user-based specifications
oCommunication and feedback to and from users is especially important during 
the early stage
System Documentation
Representing a system using systems modelling tools
-Different types of documentation are produced throughout the software 
development cycle
-Many large companies utilise diagrams that form part of the UML (unified modelling 
language) which incorporated a variety of different modelling tools that are now 
available as part of many CASE tools and IDE’s (integrated development 
environments)
-A model of a system is a representation of that system designed to show the 
structure and functionality of a system. Many system modelling tools are in the form 
of diagrams
-The model gives directions and specifications for the developers
-Different types of modelling are applicable to different aspects of the system
IPO Diagrams
-Explain how inputs are transformed into
outputs by processing
-Expand on the processes found in the
data flow diagram and structure
diagram
-IPO diagram can either be
diagrammatical or table form
Context Diagrams
-Used to present an overview of the whole system
-Shown as a single process along with the inputs and outputs
-Attempt to show the data entering and information exiting the system without 
detailing the processing required in any detail.
- The squares are referred to as external entities. 
-Connected to single process by data flow arrows
-Elements are labelled
-Does not show data stores nor internal processes
-Context diagrams are referred to as level 0 data flow diagrams
-Helpful with understanding how system interfaces with the environment
-Process: a circle
-Arrow – flow of data
-External entity/rectangle – person or organisation, source or sink that provides or 
receives data
Data Flow Diagrams
-Represent a system as several process that together form a single system
-Refinement of a context diagram
-Show a further level of detail not shown in context diagrams
Structure Charts
-Describe the top down design and sequence of processing
-Represent a system by showing the separate modules or subroutines that 
compromise the system and their relationship to each other
-Chart is read from top to bottom, with component modules or subroutines on 
successively lower levels, indicating these models or subroutines are called by the 
module or subroutine above.
-Modules are read left to right to show the order of execution
-These modules set the structure for the development of the IPO diagrams and then 
the development of the algorithm and subsequent coding of each module
-Structure charts are useful for maintenance 
-Symbols used
oOpen arrow – data movement between modules or subroutines, usually passes
as parameters
oClosed arrow – indicate a flag or control variable
oSmall diamond at intersection – a decision
oUndo arrow – repetition
oLine – call the module
System Flowcharts
-Used to represent the logic and
movement of data between the
system components, including
hardware, software and manual
components
-System flowcharts are a
diagrammatic way of representing
the system to show the flow of
data, the separate modules
comprising the system and the
media used
-Many symbols for system flowcharts have become outdated because of changes in 
technology
-Symbols:
Data dictionaries
-Comprehensive description of each data item in a system
-Commonly includes:
oVariable name
oSize in bytes
oNumber of characters as displayed on screen
oData type
oFormat including decimal points if applicable
oDescription
oExample
Algorithms used to document the logic in modules and 
subroutines
-The logic in modules and subroutines are represented before coding using 
pseudocode and Flowcharting
-Pseudocode uses English-like statements with defined rules of structure and 
keywords
-Flowchart is a graphical representation
-Flowcharts should not be used for large projects
Test data and expected output
-Many operational factors may be outside the control of the programmer, or unable to
be foreseen (e.g. inputs, variation in hardware, different OS and changing 
technologies)
-Programmer can only test the program within the bounds that are set during the 
analysis stage of development
-With an increasing size of an application it makes it harder to create test data to run 
throughout the whole application
-Modularisation of programs means that data can be created to test each module 
however it is also likely that an unforeseen output from one module will cause 
problems in other modules in the program
Communication issues between client and developer
Need to consult with the client
-Implementation of a new system is generally easier if stakeholders feel that they have
contributed to the development
-Many conflicts can be avoided if good communication is carried out between the 
developers and the users
-Developers are familiar with the technical aspects of the development of a new 
system
-The users are familiar with the operation of the current system and can provide good 
feedback and screen design operation and training requirements
-Good communication is achieved by:
oempowering the user
oacknowledging the user’s knowledge and perspective
oenabling and accepting feedback 
The need to incorporate the client’s perspective
-the developer and user are equally important to the success of the software project, 
and the developer must accept the expertise of the user and use it to better 
understand the system
-user perspective should be considered while designing both the processes and the 
interfaces
The need for the developer to enable and consider feedback
-for effective communication, developers need to establish both formal and informal 
channels and communication
-formal channels
omemos and regular meeting to keep the users up to date with the 
development process
-informal channels
odiscussed at any time during development process, as quite often matters will 
arise that cannot be kept until the next formal meeting
-user should have the opportunity to provide feedback
-development process will proceed well if members can achieve constructive criticism 
and if there is two-way communication
The need to involve and empower the client during the 
development process
-changing work practices are often cause for discomfort, resentment and fear
-people who are going to be affected by a software change will more readily accept 
them and if they feel that they have had input into the design process and will have a 
sense of ownership of the product
-ownership is especially important after installation, as users are more likely to 
describe problems or suggest enhancements
-empowering the user also means giving them the ability to make decisions that affect
their work
Quality Assurance
Refers to the planned and systematic activities implemented in a quality system so that 
quality requirements for a product or service will be fulfilled.
-Quality assurance involves:
othe need to define the criteria on which the quality of the product will be 
judged and may include requirements
oputting in place management processes to ensure that quality criteria is being 
met
oan ongoing QA process to ensure quality criteria is being met
-A set or list of measurable criteria is required
-The criteria to judge the quality of the project is considered and set early
-SQA ensures that software will function reliably as intended and is free of errors
-Includes:
oEfficiency – best use of computer’s resources
oIntegrity – correctness of data within the system
oReliability – ability of the system to continue to perform its functions over time
oUsability – ability of software to be learned and used by new users
oAccuracy – software performs its functions correctly and according to 
specifications
Can only be assured when code has been thoroughly tested
oMaintainability – measure of ease with change to software
oTestability – individual modules and subroutines should be able to and have 
been thoroughly tested and system should be tested to ensure it performs 
according to requirements
oRe-usability – ability to reuse code in other related systems
Programmers maintain a library of subroutines and modules that 
perform commonly used functions to ensure quicker and error free 
coding
Planning and Designing Software Solutions
Identification of appropriate modules
-Algorithms are usually written by designing modules and then the sub-modules
-This design process is called a ‘top-down design’ and is the most popular way to solve
problems with structured programs 
-Top down design is where the main module is written followed by the sub-
modules/functions it calls
Inputs, Outputs and Processes
-IPO charts look at the processing of data
-Also address the management of data; where it comes from, how we store it, how it 
is used in processing and its format or type for output
Consideration of global and local variables
-Consideration of global and local variables should be done in the design stage
-Local variables are only used in the module which they are declared
-Any modules can access global variables
Scope of variables
-Where the variables are declared/created/used
-Scope describes where in the algorithm the variable can be used
Parameters
-Components of functions
-Identify values that are passed into a function
-Passed from mainline to sub-program
Standard Algorithms
-Linear search
-Finding maximum or minimum values
-Binary search
-Insertion sort
-Selection sort
-Bubble sort
-Processing strings (extracting, deleting and inserting)
-Generating set of unique random numbers
-Processing of sequential and relative files
Arrays
-Structured data type
-Collection of like data
-Data is held in a cell with an index
-Cells are linear in structure
-Array has a name or label
-Arrays hold a single data type
-You can nominate the size of an array
-You do not need to fill all cells in an array
Declaring an Array
-Array is declared before values can be added
-E.g. Declare Array (1-5) as type string
Accessing an Array
-To find (access) the third data element in the ‘array’ = array (3)
-Will return third index value
-To assign a simple variable a value from an array: myarray = array (2)
Sentinel Value
-Used to mark the end of a data list
-EOF – end of file
-Indicates last entry of fata in the structure, so processing can cease
Linear Search
-Examining one item at a time in an array beginning at the first item and moving to the
end of the array
-Does not require numbers to be sorted
-Processing taken for the search is directly related to the size of the array searched
-Linear search involves:
oThe function accepting a search value
oTraverses the array using iteration
oChecks each value compared with search value
oReturns ‘number found’ and the index of cell which value equals search value
oOtherwise returns ‘number not found’
Find Maximum or Minimum
-The value in the first element is stored in a temporary variable called Max/Min
-As the array is traversed each element is considered to determine if its value is 
larger/smaller than that stored value
-If so, the value in Max/Min is replaced by this larger/smaller value, and the index of 
this element is stored in a temporary variable called MAX/Minindex
-When all elements have been considered, Max will contain largest value and 
MaxIndex will contain the index of the largest element and vice versa for minimum
BEGIN FindMAX 
Max = Numbers (0) 
MaxIndex = 0
i = 1 
REPEAT 
IF Numbers (i) > Max THEN 
Max = Element (i) 
MaxIndex = i 
END IF 
i = i + 1 
UNTIL i > NumElementsInArray 
Display “The highest value is ” Max “ at position ” MaxIndex 
END FindMAX
BEGIN FindMIN 
Min = Element (0) 
MinIndex = 0
 i = 1 
REPEAT 
IF Element (i) < Min THEN 
Min = Element (i) 
MinIndex = i 
END IF 
i = i + 1 
UNTIL i > NumElementsinArray 
Display “The smallest value is ” Min “ at position ” MinIndex 
END FindMIN
Binary Search
-Only used if the values in the array are already sorted in order
-The binary search starts by checking the middle value of an array to see if it matches 
the search value
-If not, the binary search then determines if the search value is in the first half of the 
array or the second half (after the middle value)
-This process is repeated with the remaining list of items
-Eventually the required item will be found or the list of possible items will be empty
        Return “Number not found”
       END
Insertion Sort
-Used when a large part of the data is already sorted
-During each pass the last element from the unsorted part is inserted into the 
appropriate place in the sorted part of the array
-A linear search is conducted to find the correct place to insert
-As each sorted element is checked it is moved to the left/right to make room for the 
new elements
-At each pass the sorted section of the array increases by 1
-Process continues until the unsorted section = 0
Selection Sort
-During each pass a linear search is performed
-A marker is placed at the first cell in the array and then search through the array from
that position onwards looking for the smallest value
-When the smallest value is found, it is swapped with the marker’s cell value. This 
naturally places the smallest value at the front of the array
-The next step is to increment the marker to the next cell and repeat the process. 
When the marker reaches the last cell, the array is sorted.
-procedure selection sort 
-   list  : array of items
-   n     : size of list
-
-   for i = 1 to n - 1
-   /* set current element as minimum*/
-      min = i    
-  
-      /* check the element to be minimum */
-
-      for j = i+1 to n 
-         if list[j] < list[min] then
-            min = j;
-         end if
-      end for
-
-      /* swap the minimum element with the current 
element*/
-      if indexMin != i  then
-         swap list[min] and list[i]
-      end if
-   end for
-
-end procedure
swap procedure would include temp value
Bubble Sort
-popular amongst novice programmers
-main logical structure is based on traversing an array and switching adjacent pairs of 
values that are not in the correct order
-after one travers the largest value will have ‘bubbled’ to the end of the array. This is 
repeated until all values are in the correct cells 
BEGIN bubbleSort with numbers 
Set index to first index of numbers +1 
WHILE index <= last index of numbers 
IF numbers[index –1] > numbers[index] THEN 
Swap(numbers[index –1] and numbers[index]) 
ENDIF
 Increment index 
ENDWHILE 
END
Processing Strings
-string – string of characters one after another forming a sequence
String Concepts
-in traditional systems strings were not identified directly in a programming language
-a programmer had to work with the individual characters that make up a message or 
word
-a string was represented as an array of character
-commonly given a default value of 256 characters
-common operations include
odetermining the length of the string
ojoining strings together – concatenation
oextracting characters from the string
oinserting characters into the string
odeleting characters
Determining length of string
BEGIN StringLength(String) 
Index = 0 
WHILE String[Index] contains a character 
Increment Index 
ENDWHILE 
Length = Index
 RETURN Length 
END StringLength
Extracting 
BEGIN ExtractString(StartPosition, NoOfCharactersToExtract) 
Index = StartPosition 
Counter = 0 
Set NewString() to an empty array of characters 
WHILE Counter <= NoOfCharactersToExtract 
NewString[Counter] = OriginalString[Index] 
Increment Index 
Increment Counter 
ENDWHILE 
RETURN NewString 
END ExtractString
Inserting
BEGIN InsertString(NewString, PositionToInsert)
  ‘Calculate Length of original and new strings’ 
OriginalStringLength = StringLength(OriginalString) 
NewStringLength = StringLength(NewString) 
TempStringLength = 0 
Index = 0 
ExtractOriginal(PositionToInsert, OriginalStringLength) 
InsertNewString(PositionToInsert, NewStringLength) 
ReplaceOriginal(Index, TempStringLength) 
END InsertString 
BEGIN ExtractOriginal(PositionToInsert, OriginalStringLength)
 ‘Create a copy of the end of the original string’ 
Index = PositionToInsert 
Counter = 0 
Set TempString() to an empty array of characters 
WHILE Index <= OriginalStringLength 
TempString[Counter] = OriginalString[Index] 
Increment Index 
Increment Counter
 ENDWHILE TempStringLength = Index 
RETURN TempStringLength 
END ExtractOriginal 
BEGIN InsertNewString(PositionToInsert, NewStringLength) 
‘Insert new string’ 
Index = PositionToInsert
 Counter = 0 
WHILE Counter <= NewStringLength 
OriginalString[Index] = NewString[Counter] 
Increment Index 
Increment Counter
 ENDWHILE 
RETURN Index 
END InsertNewString 
BEGIN ReplaceOriginal(Index, TempStringLength) 
‘Attach end of original string back onto the string’ 
Counter = 0 
WHILE Counter <= TempStringLength
 OriginalString[Index] = TempString[Counter] 
Increment Index
 Increment Counter 
ENDWHILE 
END ReplaceOriginal
Deleting
BEGIN DeleteString(StartPosition, NoOfCharactersToDelete) 
Index = StartPosition 
OriginalStringLength = StringLength(OriginalString) 
WHILE Index <= OriginalStringLength - noOfCharactersToDelete 
‘Overwrites elements to be deleted
 OriginalString[Index] = OriginalString[Index + NoOfCharactersToDelete] 
Increment Index 
ENDWHILE 
WHILE Index <= OriginalStringLength 
OriginalString[Index] = “” 
‘Clear contents of these elements 
Increment Index 
ENDWHILE 
‘The original str string will now be NoOfCharacters Shorter
 END DeleteString
Generating set of unique random numbers
-most high-level languages have a function to generate a random integer or floating-
point number
-generally, a range in the random function is specified
-random number generators have applications in gambling, statistical sampling, 
computer simulation, cryptography
-the generation of pseudo random numbers is an important and common task in 
computer programming
-different applications require different amounts of unpredictability
-most computer-generated random numbers use Pseudo random number generators 
(PRNGs) which are algorithms that can automatically create long runs of numbers 
with random properties but eventually the sequence repeats
-the series of values generated by such algorithms is generally determined by a fixed 
number called a seed
-one if the most common PRNG is the linear congruential generator which uses the 
recurrence:
X n + 1 = ( a X n + b ) mod m {\displaystyle X_{n+1}=(aX_{n}+b)\,{\textrm {mod}}\,m} X_{n+1}
= (a X_n + b)\, \textrm{mod}\, m to generate numbers, where a, b and m are large integers, 
and X n + 1 {\displaystyle X_{n+1}} X_{{n+1}} is the next in X as a series of pseudo-random 
numbers. The maximum number of numbers the formula can produce is the modulus, m.
-processing a set of unique and random numbers requires
oan array to store the numbers
oa loop to generate each number
oand random generator function
oadding to final array of numbers
oa check to see if the number is unique
BEGIN randArray(min, max, num) 
FOR I = 0 to max – min 
rNum(i) = I + min 
NEXT i FOR I = 0 to num – 1 
R = random integer from I to (max – min) inclusive 
Arr(i) = rNum(r) 
rNum(r) = rNum(i) 
NEXT i 
RETURN arr 
END
The VB Rnd function returns a value less than 1, but greater than or equal to zero. The value
of Number determines how Rnd generates a random number. For any given initial seed, the 
same number sequence is generated because each successive call to the Rnd function uses 
the previously generated number as a seed for the next number in the sequence. Before 
calling Rnd, use the Randomize statement without an argument to initialize the random-
number generator with a seed based on the system timer. 
In VB a random number function using Rnd(): randomVa lue = CInt(Math.Floor((upperbound
- lowerbound + 1) * Rnd())) + lowerbound
Processing of sequential files
-the data stored in a sequential file is stored in a continuous string
-the data is accessed from beginning to end
-text files are sequential files
-sentinel files are used to indicate the end of a file
-once sequential files are read and the sentinel is reached, files are closed
Priming read
-the statement which reads the first input data record prior to starting a structured 
loop
-the main purpose of a priming read is to allows the processing block that follows it to 
be structured
Open for input, output or append
Sequential files can be opened in one of three modes:
1. Input – used to read the data within a file
2. Output – used to write data to a new file
3. Append – used to write data at the end of an existing file
Processing of relative files
-Relative refers to the position of a record in the file as each record is the same length
-Allows the relative position of a record to be known
-The position of each record in the file is used as a key to allows direct access of a 
record (instead of sequential)
-Relative files are used to store records
-Each record is the same data type and length
-Fields are usually padded out with blank characters
Retrieving, writing and updating a record in a relative file
-Relative files need to be open for relative access to be updated and must be closed 
before the program ends
-All records are accessed using a key which specifies the relative position of that 
record within the file.
-The key fields used must contain positive integer values only
-E.g. follow algorithm allows the price of any product to be changed:
 Dog
Interface Design in software Solutions
-Designs of screen will be influenced by the nature of the problem.
Consideration of the intended audience
Each screen in a program will have a target audience. If the screen is to be effective, the 
needs of that audience must be met:
-Organisation of screen elements
-The way they are presented
-The way the user interacts with the interface and the way help is provided
Communication with the user is key to finding out the specifications for interface design 
depending on the target audience.
Identification of screen size
-Screen size will be affected by the intended hardware the software will be installed on
-Will also impact screen resolutions and graphics hardware and drivers
Identification of data fields and screen elements
-Screens are designed to present data, input data or output data
-It is important for the developer to have a clear understanding of how data items 
need to be presented to the user
-The context in which data is displayed is closely related to the processes being carried
out.
oMenus are used to initiate executions of modules within a program
oCommand buttons are used to select a different path for execution, often used 
for confirmations
oTool bars; used to quickly access commonly used items
oText boxes; receive input in the form of strings
oList boxes; force the user to select from the given options
oCombinations boxes; combine functions of text box and list box
oCheck boxes; obtain Boolean input from the user
oOptions or radio buttons; select from one of the displayed options
oScroll bars; navigation
oGrid; likened to an array of records
oLabels; provide guidance and information to the user
oPicture/image box; display graphics
Online help and user feedback
-Help system should be designed to encourage user to seek assistance immediately a 
problem is encountered
-Context sensitive help
oIf user asks for help, new window displayed containing information about 
user’s last action
oSmall windows can open to display simple tips relating to current screen 
elements if the user holds the mouse over an element for more than a few 
seconds
-Procedural help
oConcise and accurate instructions on how to complete a specific task
o‘how’ rather than ‘why’
-Conceptual help
oAims to explain ‘what’ and ‘why’ rather than ‘how’
oTours, tutorials and wizards
Consistency in Approach
-Must be consistency between screens within an application
-Allows the user to anticipate actions and placement
-Design rules should be created before the development process is undertaken
oEspecially important when a team of programmers is employed
-Transfer across to new product
-Aspects of consistency
oNames of commands
oUse of icons
oPlacement of screen elements
oFeedback
oForgiveness 
Customised off the shelf packages
-Identifying an appropriate package
oCost benefit analysis; if a package will take more time and effort rather than to 
build a new application from scratch it is not worth modifying
-Identifying the changes that need to be made
-Obtaining permission from original author
-Identifying how the changes are to be made
Standard modules and library routines
Reasons for development and use of standard modules
-Consideration of local and global variables
oLocal variables can only be used within their own module/subprogram
oGlobal variables can be accessed throughout the whole program
oScope: refers to the amount of the program in which the variable can be used
-Appropriate use of parameters
Identification of appropriate modules or subroutine
-Thorough documentation including intrinsic naming of variables and objects
-Standard control structures are utilised
-Choice of language suits the module
-Social and ethical issues related to the modules
-Modules that contain redundant tasks will only waste memory
Appropriate testing using drivers
-Drivers are temporary code used to test the execution of a module when the module 
cannot function individually without a mainline     
Recognition of relevant social and ethical issues
-Ease of use
-Accessibility of technical language
-Copyright
-Ergonomics
Factors considered when choosing a language
Sequential or event driven software
-Sequential
oScreens follow one after the other and minimum user input is required
oData items are accessed from outside of the program
-Event-driven
oData items are accessed from within the program and the user controls the 
order of processing, creates an interactive and dynamic pattern to follow
Driven by user or programmer
-User
oProgram logic
oRequires user’s actions to trigger an event
oFeatures menus, buttons, icons etc.
oOrder of module execution is defined by the user
oPolling: process of continuously checking the status of events
oEvent parsing: executes events that the user has instigated
oUsed in computer games
-Programmer
oSequential approach
oFollows set of steps to solve a given problem
oUtilises standard control structures such as Begin… End, Do… Until
oOrder of module execution is defined by the programmer
oUsed in data handling programs such as databases and word processers
Other
-Hardware requirements
-Is GUI required
-Experience of the developers
Features requires and available in the language
-Commands within the language to interface with the required hardware
-Ability to run under different operating systems
Factors considered for use of technology
Performance requirements
-Minimum hardware configuration
oProcessor type and speed
oPrimary storage (RAM) available
oSpecific input and output devices
oSecondary storage size and type
oA minimum operating system
-Requirements either come from purpose of the software, others from the system 
being used to convert the source code into executable code
Benchmarking
-Involves creating a set of tasks that can be used to measure the speed with which a 
computer system will perform a task
-Allows for a comparison between different combinations of hardware and software
-Purely objective process and so subjective measurements of aspects such as user 
friendliness and ergonomic factors are not included in the process
-Interpreting these results are just as important as obtaining them.
Implementation of software solutions
Language syntax required for software solutions
Railroad diagram
-Alternative graphical method used to define the syntax of a programming language
-Rectangles are used to enclose non-terminal symbols, that is, symbols that will be 
further defined
-Circles or rounded rectangles are used to enclose terminal symbols
-Linked by paths to show all valid combinations
-By starting at the left-hand side of the diagram and tracing any path in a forward 
direction to reach the right-hand side of the diagram, a syntactically correct construct 
is defined
Extended Backus-Naur Forms (EBNF)
-Symbols:
o<...> represents a defined element (non-terminal symbol)
o| represents an alternative
o: = represents a statement is defined
o{…} represents repeated elements
o[…] represents optional elements
o(…) represents grouped elements
Metalanguage descriptions of programming languages
Declaring multi-dimensional arrays and arrays of records
In general, declaring a variable for use within a program involves two stages. Firstly, if the 
data type or structure does not already exist in the language then it must be defined. 
Secondly, a variable of the required type is declared.
Translation methods in software solutions
-High level languages cannot be directly understood by a processor. Instructions must 
be converted into binary. Source code  machine executable code
-Source code is said to be machine independent; can be used on several different 
processors.
-Executable code is very processor specific, each different family of processors will 
have different machine language instructions
Compilation
-Takes source code and produces a complete translated file
-Compiling is machine CPU specific
-This file can be used on other machines with same CPU without a need for translator
-Batch process
-Unwanted code, such as comments/remarks, are removed therefore creating code 
that is more efficient
-Allows for use of share resource and libraries
-Each time a change is made, the whole program must be recompiled
-Slower testing and error detection phase
-All coding errors are reported at the end
Interpretation
-Translation but slower, less efficient object code as each line is translated when 
loaded into memory
-Line by line translation and execution
-Much slower overall executions
-Errors reported line by line; instant error feedback
-Early error detection of runtime errors
-When error is detected, execution is halted
-Users must have the interpreter on their computer
Incremental compilation
-Compiles each line of source code and adds it to object file
-Line by line translation
-Errors reported instantly
-Result is still a compiled object file
Compilation Interpretation
Advantages Runs faster and more efficient
Source code is private
Cross platform
Easier debugging
Disadvantages Executables created with compilers
are machine specific; not cross 
platform
If it is to operate on a different 
processor/operating system, 
source code must be recompiled, 
longer to develop in
Slows down execution significantly 
because of each statement needing
to be translated before it is 
executed
Public source
Users of interpreted programs must
have copy of the interpreter
Compilation process in detail
The three translation methods are similar differing only by what occurs after a line of code 
in converted.
Lexical analysis (scanning)
-Source code is broken up into lines of code
-All formatting is removed, and comments are removed
-Each group of characters on the line checked against a syntax library held in memory.
-Individual language elements such as constructs called lexemes are identified and 
labelled with a token
-The process checks reserved words, identifiers, constants and operators are correct
-Identifier tokens are stored in a symbol table or token dictionary
-The translator uses attributes in the symbol table to allocate memory to variables
Syntactic analysis (parsing)
-Parsing implements the syntax rules of the programming language
-If a group of tokens do not conform to the syntax rules the analyser cannot place 
them in the parse tree  error is reported
-The analyser reports the error to the programmer
-The tokens pass from the scanner to the syntactic analyser
-The syntactic analyser arranges tokens so computer (CPU) understands logic of 
program being translated
-Arrangement can be written as a parse tree
Type checking (part of parsing)
-Parsed tokens are sent to the type checker
-Type checker has two purposes
oDetection of data types within the tokens and passing data type detection to 
the translator
oDetecting incompatible operation between data types and creation of error 
messages
Code generation
-If the process of lexical analysis and syntactical analysis have been completed without
error, then the machine code can be generated. 
-Involves converting each token or series of tokens into their respective machine code 
instructions
-No errors should be found during code generation
-The parse tree created during syntactical analysis will contain the tokens in their 
correct order for code generation and these tokens will be converted into their 
respective machine code
-Links are created to any external files required at runtime – such as DLLs and other 
executable libraries
Role of machine code in the execution of a program
CPU
-Fetches the instruction from primary storage
-Decodes the instructions
-Executes the instructions that are expressed and stores the result
-Control unit coordinates the actions of the processor
-Arithmetic and logical unit is responsible for all the arithmetical and logical 
operations carried out by the processor
-Registers (memories) are provided to store results, locations of instructions and flags
Above components are joined by internal data bus system
The processor is connected to main memory via an external data bus system
The CPU contains a microcode instruction set which are permanently set in the CPU 
sometimes referred to as firmware.
Machine code and CPU operation
Instruction format
-Machine instructions need to convey several pieces of information
-An instruction is the command given to the central processing unit by a computer 
program
-Instructions are made up of an operation code and a memory address
-The first few bits are used to tell the CPU the type of instruction to be carried out
-An operation code is a machine language for a single operation
-The control unit interprets this code to determine the appropriate action
-First four values represent command ‘copy’
-Next four represent the command ‘into the accumulator the value that follows’
-Instruction byte 2 and 3 represent the memory location that supplies the data
-This type of instruction is called direct addressing of a memory location
-Processor instructions are grouped into sets
Use of registers and accumulators
-A register is a temporary storage location within the central processing unit
- Working registers are referred to as accumulators. Data leaving the main CPU goes 
through the register buffer
- Accumulators hold the data items currently being processed
-an accumulator is a register which stores the result of the latest computation carried 
out by the CPU or the last data that is about to be computed
- data is stored in the registers and results are passed from registers back to main 
memory
- special purpose registers are used to store bits known as flags
-After being in the accumulator, the data must be moved to a different memory 
location
Fetch-execute cycle
1. Fetch instruction from primary memory and place in instruction register
2. Set program counter to the next instructions address
3. Decode the instruction
4. Load operands from memory into a register
5. Execute the instruction and store result in an accumulator (generally the ALU will 
execute the task)
6. Reset
Use of a program counter and instruction register
-The program counter is a register that is part of the computer’s CPU
-The program counter stores the address of the next instruction to be executed
-Instructions are generally stored sequentially unless the instruction is to change the 
program counter
-The instruction register is where the instruction is either being decoded or executed 
is stored
Execution of called routines
-A register called the ‘stack pointer’ is used to keep track of the location of the 
beginning of a part of main memory known as the stack
-The stack is then used by CPU to hold the address of the next instruction when a 
subprogram is run or called
-The CPU can then return to the correct position in the main program when the 
subprogram is finished
-The stack is a set of locations in main memory used by the CPU
-The stack is a LIFO list
-The last location in the stack to have a value places in it is called the top of the stack
Linking, including use of DLLs
-Linking allows for a machine code program to be combined with another machine 
code program
-Because larger programs are modular in nature, the linker is used to join these 
modules
-Since programs must be in the RAM to be executed, linkers save resources because 
only the needed modules are loaded
-DLLs are a library of machine code programs which can be accessed by others to 
perform specific tasks
-DLL files allows programs common access to resources and provide efficient use of 
the memory
-When a program requires a sub procedure it’s address is stored in a linker
-The linker calls the sub routine into the main program
-The sub routine gains control
-When finished, control is passed back to the main program
- Provides method of updating software without rewriting main program
https://www.youtube.com/watch?v=jFDMZpkUWCw
fetch decode execute cycle steps
1. Program counter stores address of next instruction to be fetched
2. Before fetch instruction memory address must be put in memory address register
3. Contents of memory address loaded into memory data register
4. Instruction placed inside current instruction register
5. Program counter increment by 1 (always points to next instruction before previous is 
fulfilled)
6. Loads current instruction register into control unit using internal bus links
7. Memory address of memory to be fetch goes into memory address register
8. Take contents of memory location and put in memory data register
9. That contents of memory address placed into accumulator
10.Then fetches next instruction from program counter and puts in memory address 
register
11.Memory address contents into memory data register
12.Then move to current instruction register
13.Program counter incremented
14.Data moved to control unit 
15.Add data to accumulator 
16.Contents of accumulator moved to ALU
17.Fetches next memory using memory address register and memory data register
18.Put into accumulator then added to ALU
19.Place result in accumulator
20.Fetches next instruction using same process then stores accumulator into memory 
address
Techniques used in developing well-written code
Use of good programming practices
A clear and uncluttered mainline
-Software projects should be developed using a clear modular approach
-In general, the mainline should be clear and uncluttered so it is easy to follow and 
identify subroutine calls
-This means that the subroutines are coded and tested independently which is better 
for maintenance reasons
One logical task per subroutine
-The name should be able to describe the algorithm succinctly
-When the algorithm becomes too long it becomes more difficult to understand and 
therefore to maintain
Use of stubs
-A stub is an incomplete function that has the same name and interface as the final 
form but simpler
-Stubs usually only contain an output statement to indicate the function was called
-It is used in testing the implementation of a program
Appropriate use of control structures and data structures
-Control structures should only use recognised statements such as pre or post-test 
loops
-The condition for the loop should determine the only exit from the loop
-There shouldn’t be jumps that cause control to exit a loop or selection unexpectedly
-Types and unusual cases should be considered when making repetition or selection 
structures
-Data structures such as arrays, records, array of records and other should be selected 
and designed to assist processing
Writing for subsequent maintenance
-Coding should be done in such a way that future maintenance programmers can 
easily update the code
-Good ways to make the code accessible for maintenance includes:
oClear documentation within the code
oAppropriate identifiers names
oIndenting within control structures
Version control and regular backup
-During coding all programmers should regularly save their work to prevent loss and 
allow for different versions of the program or module
-Regular backup should be done to various devices instead of single one to prevent 
absolute loss
-Version control allows complete applications to be continuously developed with 
regular version being released to users
-Version control allows reversion to a previous version any time in the future
-Version control systems are routinely used by teams of programmers because it 
routinely does all the above functions
Recognition of relevant social and ethical issues
-Social and ethical issues should be considered when developing:
oIntellectual property 
oThorough testing
oDocumentation for future developers and maintainers
The process of detecting and correcting errors
Syntax errors
-Syntax errors are involved in the translation process
-Syntax errors prevent the translating high-level code to object code
-Syntax errors are detected as a result of lexical analysis and syntactical analysis in the 
translation process
-Once a syntax error has been detected it is usually a simple task to correct
Logic errors
-Logic errors are the result of syntactically correct code that does not complete the 
required task
-Logic errors are the most difficult error to correct
-It is impossible for the development environment to detect logic errors and logic 
errors are detected in the running of the program
Runtime errors
-Runtime errors are errors that occur while executing:
oArithmetic errors
Involves the incorrect use of data types and data structures
Usually occurs when the result cannot be stored properly
oDivision by zero
oAccessing inappropriate memory locations
Error occurs when inappropriate memory locations are accessed
Methods of error detection and correction
Use of flags
-Flags are a marker placed in the code to signal a change in status
-Code that will change the value of a flag is added to an appropriate location
Methodical approach to the isolation of logic errors
-The programmer may use the comment tool to stop code from running
-Programmers may also comment out blocks of code and systematically find the 
precise location of an error
Use of debugging output statements
-Debugging output statements are temporary lines of code added to display the value 
of a variable
-It may also be used to state that a part of code has been reached
Peer checking
-Involves the checking of the code along with the other person/programmer
Desk checking
-Test data is used to compare the actual result with the expected results
-Use structured walk through to step through the code and find where errors occur
-Desk checking should be performed on sub and whole programs
Structured walkthrough
-Structured walkthrough are more formal than peer checks
-No attempt is made to correct problems only feedback is given
-Made to evaluate design at different levels
Comparison of actual with expected output
-If initial tests actual output should be compared with expected output that has been 
determined in the planning and design stage
-If actual and expected output are the same, then it is considered an error in logic has 
occurred
-All paths in logic should be tested
-Often in large productions subroutines or individual modules are tested individuals 
for logic errors
-Testing software may assist in the testing of logic particularly in large software 
developments
Use of software debugging tools
Use of breakpoints
-A simple technique which may temporarily or permanently stop executions
-Used to check variable contents before and after processes occur
-Breakpoints are placed in areas where error may exist to locate the source of error
-Development environments usually allows lines of code to be marked with a 
breakpoint
Resetting variable contents
-The data stored in a variable can be changed while the program is running
-The program is usually halted using a breakpoint
-Can be used to check which values are giving errors by changing the values when 
execution has stopped
Program traces
-Allows the programmer to view progress of the program execution in detail
-The order of line executions is tracked analysing the flow of the statements
-Particularly useful for following the progress of the program through nested loops or 
complicated sections
-A log of transactions is often created, and this trace log can be used to identify source
of errors
Single line stepping
-A variable trace enables the programmer to observe the variable changing 
throughout the program
-Single line stepping is the process of halting the executions after each line or 
statement
-A keystroke is usually required to step through lines
-Usually used to concentrate on a sub routine instead of the whole program
Watch expressions
-A watch expression is an expression whose value is written to a separate watch 
window
-Usually watch expressions are variables and calculations separate to the program 
lines of code
-This can provide automated desk checking
Documentation of a software solution
User documentation
User manual and reference manual 
-Paper or online external documentation that is user friendly so an everyday user can 
understand the information presented, and is provided to the user for instructions on 
how to use the software effectively
-The manual needs to be designed with accordance to the level of expertise the target 
user had and needs to cater for the experienced and inexperienced
-Should state:
oHow to get started
oHow users may use common functions
oHow to fix mistakes
oHow to recover work that may have been lost
oTroubleshooting guide
Installation guide 
-A program installation guide is also included within user documentation and should 
include:
oDetails on how to install the program and descriptions of the mediums 
supplied
oMinimum hardware specifications
oDetails of any known conflicts with any other software
-It is very useful to use screen shots in the user manual as the users can effectively 
compare what stage they are up to and confirm that they are on the right track
User tutorials
-Guide the user through the steps of working with features of a program
-Tutorials usually train the user how to use the program
Online help
-Online help systems provide updated solutions to various problems, providing the 
user with information from the internet – FAQ’s are also provided to aid the user
-Having the help documentation online enables easy addition and updating of the help
information
-Internet connections are usually required
Technical documentation
Logbooks 
-Log kept by the development team of all the steps taken in the development process
-Annotated and dated regularly to avoid loss of important steps and tests
Systems documentation
-Systems documentation should provide a description of the operation of the program
including the use of subprograms and any special features of the code
-Should include documentation on how to configure the hardware and software 
required
Algorithms
-Primarily used during program design to provide a clear description of the steps 
carried out to solve the problem
-Allow maintenance programmers to determine the structure of the program
Source code
-Programming code that makes up a program
-Documentation within the source code are in the form of comments and intrinsic 
information
Use of CASE tools to assist in the documentation process
-CASE tools may be used during the development
-CASE tools use templates for documentation
-CASE tools provide a standardised approach to documentation
-Automates process of documentation
Hardware environment to enable implementation of the software
solution
Hardware requirements
Minimum configuration
Commercial software products will usually have a minimum configuration on which the 
software will run reliably:
-What type of computer hardware CPU?
-The amount of RAM required for the program to run
-The amount of hard disk space required for the program
-The OS under which the software will run
Possible additional hardware
As programs become more complex, they require greater hardware requirements. This 
could come in the form of needing more RAM or a discrete graphics card. Some programs 
may also require other IO devices such as a barcode scanner or Bluetooth connectivity
Appropriate device drivers or extensions
Drivers: additional small programs required to run or execute tasks carried out by peripheral
devices
Extensions: files that usually reside with the OS and assist in the execution of some 
programs
-Dynamic link libraries are extensions
These add-ons are necessary for a program to run successfully and provide all its features
If a program is required to have any of these add-ons, they should be provided by the 
software developer to the user or have instructions in how to download and install them.
Emerging technologies
The effect of emerging hardware and software technologies 
have on the development process
Involves learning about:
-New programming techniques
-New programming languages
-Emerging hardware developments
-Emerging software
-The effects software may have on the users
-The effects on traditional developments processes.
Testing and Evaluation of Software Solutions
Alpha testing: Testing of the final solution by personnel within the software development 
company prior to the product’s release.
Beta testing: testing of the final solution by a limited number of users outside the software 
development company using real world data and conditions.
Two aspects to testing a software solution:
1. Validation: process of comparing the solution with the design specifications
2. Verification: process of ensuring that the software performs its function correctly
Comparison of solution with the design specifications
Design specifications should be written in a form that provides a set of measurable 
performance criteria. The following guidelines can be used to review the design 
specifications.
-Ensure specifications are written in terms of measurable outcomes
-Clarify any vague terms (sometimes, usually etc.) 
-Clarify and ambiguous statements
-Incomplete lists of items should be avoided
-Calculations should be accompanied by examples
-Pictures and diagrams should be used to clarify structure
If the above is followed in the specification document, an objective evaluation of the project
can be made. The process of validation involves the use of the software in a real situation 
with real data so its performance can be compared under conditions that are close as 
possible to final environment.
Generating relevant test data
Operational factors outside the control of the programmer:
-User and environment inputs
-Variations in hardware such as CPU, memory, graphics processors, and peripherals
-Different OS
-Changing technologies such as cloud storage and wireless systems
Black box testing
-Also known as functional testing. The inputs and expected outputs are known; the 
processes occurring are unknown.
-Does not attempt to identify the source of the problem but rather to identify that a 
problem exists. 
-Concentrates on their input and their expected output
-Boundary analysis: test data tests elements that represent either side of the 
boundary where the effects of processing are different
-Equivalence partitioning: breaking up the input data into groups that have the same 
properties
White box testing
-Also known as structural or open box testing
-Software testing technique whereby explicit knowledge of the internal workings of 
the products being tested is used
Statement coverage testing
-Execution of every statement in the module
Decision-condition coverage testing
-Involves testing the execution of each decision in a control structure with a true and 
false at least one
Exhaustive condition coverage
-Tests all the possible combinations of true and false for each condition
-Bring out any unexpected errors that may occur with unusual data combinations
-Very thorough
Levels of Testing
Testing should occur at:
-Module or subroutine level
-Combination of modules as program testing
-After compilation known as system level testing
Module testing
-Black box
-White box
-Treats every module as a stand-alone application
-Different errors:
oArithmetic
oComparison
oControl logic
oData structure
oInput/output
oInterface errors
Program testing
-Also known as integration testing
-Interaction between modules may causes errors
top down approach
-Program driver module is first tested with stubs representing the lower modules
-Once driver works with stubs, modules are gradually added
-Tested every time you add module until full program is made
-Understand which modules are causing the errors
Bottom up approach
-Involves testing the lower end module first then adding them together one by one 
then testing, modifying and retesting the larger module until it functions correctly
Followed by acceptance testing to ensure that the program fits into the processes and 
procedures of the system for which it was designed.
System Level Testing
System components to create suitable test environments
Hardware
-Software product should be installed and tested on different combinations of 
hardware ranging from minimum requirements to additional hardware
-Focus on:
oPerformance: how well program operates; will test load and volume
oRecovery: force system to fail and then measure the ability to re-establish 
normal operating state
oSecurity: can and how system is breached
oStress: push hardware and software beyond normal operating conditions
Other system testing:
-Software: other software installed on the system may have effect on operation of 
other software products
-Data: data input is the most likely source of errors; needs to be tested with large 
combination and quantity of live test data
-Personnel and procedures: users of the system will have various skill and knowledge 
base level
oBeta testing is useful to test requirements relating to personnel who will use 
the system
Use of live test data for system testing
-During development, modules are tested with ‘designed’ data used to test operation. 
The development team cannot foresee all live scenarios of data.
-Therefore, tested using live data to test operational conditions
Large file sizes
-Use of large files will highlight problems associated with data access. 
-Often systems that perform at acceptable speeds with small data files become 
unacceptably slow when large files are accessed
-Particularly the case when data is accessed using networks
Mix of transaction types
-Testing needs to include random mixes of transaction types
-If data is altered by another transaction, then problems can occur
-Software must include mechanisms to deal with such eventualities
Response times
-The response time of an application is the time the system takes to respond to data 
input
-Live data will subject the system to real processing requests and therefore will 
provide a simulation of a real response time
-Any processes that are likely to take more than one second should provide feedback 
to the user e.g. progress bar
Volume data (load testing)
-Large amounts of data should be entered into the new system to test the application 
under extreme load conditions
-Multi-user products should be tested will large number of users entering and 
processing data simultaneously 
-CASE tools are available that enable automatic completion of data entry forms to 
simulate thousands of users entering data to load test during alpha testing
Interfaces between modules and programs
-Provides a communication link between system components
-Interface is usually provided with parameters that are used to pass data to and from 
modules.
-Require testing to make sure connections between modules work efficiently
Comparison with program test data
-Comparison can highlight any errors or problems
-The output from live data testing is compared with the output of developer testing to 
determine effectiveness
Benchmarking
-Process of evaluating a product using a series of tests; these tests provide numerical 
results that are compared with recognised standards
-Benchmark: a point of reference from which quality or excellence is measured
-These results allow users of software products to make informed purchasing 
decisions
-Benchmarking aims to reduce the number of variables and to report results 
objectively
-Compare results to competitors to maintain and improve market penetration
Quality assurance
- Clarity- precise and unambiguous instructions
- Correctness – consistent output from the same input.  
- Documentation– accurate without spelling grammar and process errors.
- Economy – economical use of software and hardware resources
- Efficiency – ease of completing tasks
- Flexibility– ability to cope with situations encountered within the operation of the 
program
- Generality– software resembling real processing
- Integrity– maintain system security
- Interoperability – software communicating with existing systems
- Maintainability– correction of problems and errors
- Modifiability – ability to change the software
- Modularity – software parts to be easily be able to be replaced.
- Portability – ability to be executed within different software and hardware 
environments
- Reliability - a measure of failure rate
- Resilience – ability to recover from abnormal situations and errors
- Reusability – modules may be reused within other similar software projects
- Understand ability – how well the design of the software is understood
- Useability - aspects important to the user, how easy program is to learn
- Validity – how the software meets the specifications of the user
Reporting the testing process
Test description including the test requirements
- States scope of testing
- States purpose and nature of system
- Procedure necessary to prepare hardware and software for testing
- A description of each test including prerequisite conditions, test inputs, expected test 
results, evaluation criteria, assumptions and constraints
- Connection of relationship of the tests to the requirements
test data including test data and expected results
- Scope of testing
- Overview of system
- Description of test environment
- List of modules to be tested, the tests to be performed and the scheduling of testing
- Connection or relationship of the tests to the requirements
Test report including results and recommendations
- Scope of testing
- Overview of testing outlining deficiencies and impacts on other parts of system
- Steps that may be taken to overcome deficiencies and impacts
- Assesses impact of testing environment
- Test result details
CASE tools
- Test data generator
- Word processor
- File comparator
- WinRunner
- LoadRunner
- DataTech
- UsableNet
Communication of testing
- The nature of the project will determine the audience for the test results
- Large software development companies usually have separate development and 
testing personnel and testers must communicate their findings back to the 
development team
Communication with the client
- Language must be non-technical
- Address any requirements and design specifications that have not been adequately 
fulfilled
- Rank problems in terms of severity
- Upfront and honest about the capabilities of the product
- To assist in the communication, it is common to give a demonstration of the system 
to the users
Communication with the developers
- Testing departments need to communicate their results back to the development 
team
- Highlight problems in order of severity
- Recommendations must be backed up by technical justifications
- Actual test data will help developers correcting or modifying product
Evaluating the software solution
Quality assurance and verification of requirements
Functional quality: how well it complies with or conforms to a given design, based on 
requirements
Structural quality: how it meets non-functional requirements that support the delivery of 
the functional requirements such as robustness or maintainability
Software quality assurance (SQA) consists of a means of monitoring the software 
engineering processes and methods used to ensure quality.
Post implementation review
- Open discussion with client if requirements have been met to a standard
- For a large development, independent review may be performed to remove any 
unintended bias
Acceptance testing
- Formals tests conducted to verify whether a system meets its requirements.
- Enables the client to determine whether to accept the new system
Client sign off process  
The client will sign off on the project when acceptance testing has been carried out and the 
client is happy with the outcome.
Maintenance of Software Solutions
Modification of code
Reasons for software maintenance involves making changes to:
1. Meet changed requirements
2. To correct problems or errors in the solution
It is common for changes after the development as user requirement evolve and change. 
Modifying and maintenance of the problem may involve the structured program 
development approach. Following this approach ensures effective changes are met.
It is important for software developers to create and maintain the documentation as well. 
Developer websites often provides the option to report an issue and download a patch for 
known issues.
Help desk support may also receive requests for changes or identity issues that need to be 
fixed. Changes would need to be prioritised based on the severity of the issue.
Patch: Used to correct a problem in a software solution. A patch is an actual piece of 
executable code that is inserted into an existing executable program.
Identification of the reasons for change
Maintenance may be carried out for the following reasons:
1. Errors in code
2. Changes in the operating environment
3. Changes in requirements, such as increased functions required by the client
Examples of reasons for modifying code:
- Poor logic in original code
- Changing user requirements
- Improvement for efficiency
- Improved security
- Upgrading the user interface
- Changes in data to be processed
- New hardware and/or software
- Changes in business requirements
- Changes in government requirements
Operating environment changes may include:
1. Changes in the programs that interface with the program;
2. Changes in the operating system
3. Changes in hardware and associated utilities/drivers
Location of the section of code to be changed
- When an error in a program has been detected the developer must be able to find 
the location within the source code.
- Well-structured and well documented code will simplify the process of isolating and 
correcting errors.
- When a modification is to be made, design documentation and source code will be 
used to determine the exact location of the change is required
features that improve maintainability may include:
- Well set out design documentation – such as IPO, data flow diagrams, structure 
charts, algorithms, and source code;
- Use of variables instead of literal constants
- Constants or global variables defined at the beginning of code
- Use of meaningful identifiers (internal documentation)
- Design comments/remarks throughout code (internal documentation)
- Code that incorporates a good error reporting system
- Use of correct control structures
- Modularisation of code
- One logical task per function/sub routine
Determining changes
There may be different reasons for changes to be made:
1. Changes due to logic will require source code changes
2. Changes to interface design may involve minor layout adjustments or a completely 
new layout design
3. Addition of new functions and requirements
How are changes made or implemented?
Once errors have been detected and located how will the change be implemented.
Methods for correcting code may include:
1. Minor source code adjustments
2. Software patch which may include several minor source code adjustments
3. New version implementation which may include redesign pf several functions
4. Software reengineering may be required if several modules need improving
5. A completely new system development
All changes should be thoroughly tested before being fully implemented. Even minor source
code adjustments will need to be compiled.
Regression testing is the process of retesting a program when changes have been made.
- Each neuron has several inputs and a single output
- Each input is given a different weighting and once weighting has passed a threshold a 
neuron is fired
Issues with selection of appropriate paradigm
Nature of the problem
- Different paradigms provide the best structure and coding language choice to solve 
the problem
- Aim of the most appropriate paradigm is to increase productivity and enable the 
production of efficient and reliable solutions
Speed of code generation
- High level languages faster
Approach to testing
- Structured
oAlways testing
- Program
oTesting at end
- Automated
oCase tools
Effect on maintenance
- Use of reusable modules
- OOP is recommended
Efficiency of solution once coded
- Low-level languages are the fastest to execute but take the longest time to develop. 
- High-level languages are the slowest to execute but take the shortest time to develop.
- Imperative languages are often more efficient for basic sequential flow applications, 
as they work closely with the hardware using variables, assignments and identifiers 
and follow sequential structures. 
- Object-orientated languages are more efficient for the development of user 
productivity but are less efficient in their speed of execution.
- Logical languages can often result in excessive / inefficient processing requirements 
due the computer’s ability to find its own solution based on facts and rules, the 
processing path is not specified by the programmer.
Learning Curve (training required)
- Imperative and object-oriented are easier to learn as they are considered more 
popular and are often introduced to students as variables and standard basic 
constructs are easy to understand for a beginner
- Despite OOPs being ‘visually’ easier to learn, they still require training to fully 
understand their full capabilities.
- Logic programming languages are often thought out to be harder and specialised, 
although these are often easier to teach to children as they don’t require as much 
code or constructs to be coded. They rely on basic mathematical principles with rules 
and facts, so beginners can often relate these principles to the coding of these rules.
  Company
About Us
StuDocu World University Ranking 2021
Doing Good
Academic Integrity
Jobs
Dutch Website
Contact & Help
Frequently Asked Questions
Contact
Legal
Terms
Privacy Policy
Cookie Statement
Social
Facebook
Twitter
Instagram
YouTube
TikTok
Blog
Get the App
Copyright © 2021 StudeerSnel B.V., Keizersgracht 424, 1016 GC Amsterdam, KVK: 56829787, BTW: NL852321363B01
We use cookies in order to improve your experience. By continuing, you agree to the use of cookies and other technologies by us and our trusted partners to process personal data.
Accept