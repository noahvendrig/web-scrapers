Place
-An audience must be specified before deciding on a place to sell the product
-There are many methods of distributing software; shop fronts, online, bookstores.
-Depending on where the software is sold, it can change the perception of customer’s 
expectations
Price
-A developer has a responsibility to arrange a reasonable price for a product
-Methods for pricing a product are either a cost-plus basis, or consumer-based pricing
Promotion
-The different ways developers use to persuade people to buy products
-Developers have an ethical responsibility in what they say about their product to their
consumers
-Promotion should help customers make informed choices
-Information cannot be misleading
-Word of mouth is a very powerful promotional tool for software.
Impact of new developers and software products
New software breakthroughs are usually inventions of new thinking and therefore boom. 
New products will pop up to try and innovate against the existing product, but unless it 
provides a huge advantage, the consumer is more likely to stick with the original default 
software product.
Legal Implications
National Legal Action
RACV vs Unisys 
Claims management system  electronic storage and retrieval system
Failed expectations of software. RACV sought damages citing false representation and 
misleading conduct. Awarded damages of $4 million dollars to RACV  
Microsoft vs Apple
Microsoft released windows after Apple released Macintosh. Both systems were distributed 
before legal action was taken. A settlement was reached allowing both companies to 
distribute their OS.
 Software Development Approaches
Factors of defining approaches
-Scale of the product
-Complexity of the product
-Skills of the personnel developing the product
-Detail of the requirements
-Time for project
-Budget
5 software approaches:
-Structured
-Agile
-Rapid application development
-Prototyping
-End user
Each software development approach consists of the same stages continually repeated, but 
with the frequency and timing unique to each development cycle.
5 stages include:
-Defining and understanding the problem
-Planning and designing
-Implementation
-Testing and evaluating
-Maintenance
Structured Approach
-Time consuming, ordered and controlled
-Highest level of personnel skill required
-Product of highest size and quality
-Top down approach (waterfall method)
-Thoroughly planned, documented and monitored
-Used for large products in large companies
-Costs are high and errors can be hard to find and correct
-Requirements are understood before design and coding occurs
-Requires high project management
Agile Approach
-Emerged due to demand for products to be specifically tailored for individuals
-Places emphasis on system being developed
-In depth documentation is not needed
-Focus on team-work, cooperating, communication skills and efficient work methods
-Development team must be able to adapt to situation
-Small teams preferred; members are multiskilled
-Characterized by speed of getting to user, interaction between team and users, 
responds well to changing circumstances
-Product in development being continually updated
Prototyping approach
-Lies between structured and agile approach
-Predates the agile approach 
-Repeatedly iterates through development stages to refine user requirements
-Each prototype includes more functionality
-Intense user interaction
-Prototypes are just interactive models of the user interface
-Favoured over structured approach if ability to adapt to changing requirements is 
required
Two types of prototyping
- Concept prototyping
oInspire discussion and thought about product
oPrototype will never be final product
oUsed to develop requirements and discarded after evaluation 
- Evolutionary Prototyping
oPrototype ends up being final product
oEach successive generation of prototype is an improvement
Some software developers take this further, by considering the maintenance stage of the 
cycle as part of the designing and understanding stage of the next cycle of development
Acknowledges that the communication with users is very important and helps in the 
defining and understanding of any future products to be developed.
Rapid Application Development
-Main purpose of reducing time and money
-Result of low quality, less usability and less features. 
-RAD has only become possible due to 4th generation languages which enable visual 
production of interfaces with little coding taking place in the background
-Ability to include re-usable code which has been developed
-Integrate with other software solutions
-Development team to work very close to each other
-Continuous feedback with users
-Only meets most important requirements
-RAD lacks formal stages to reduce time and cost
-Removes need for data structures, algorithms 
-Uses existing routines and API of applications
-RAD is suited when
oDistribution is narrow
oApplication runs on small LAN
oDoes not need to interface with other software systems
-Advantages of RAD
oReduced coding of modules where library code is used
oLess errors 
oLibrary code can ensure consistent look and feel
oShorter development cycle
End User 
-never used in software companies, not made for purpose of making money
-used to address a specific problem that end user needs a solution for
-very small budget
-does not require knowledge of workings of a computer, as it uses Customised off the 
shelf (COTS), Wizards or other automated code generating devices.
-Resulting programs will not be overly complex and may not meet specifications that 
the user may have initially wanted
-Advantages of End User approach
oThe solution can be revised and modified at will, without consultation with 
other users
oNo money required
oLess development time required
oA freedom to change requirements at any stage
Combinations of Software Development Approaches
-Does not have to be of one type or another
-Combinations of approaches are perfectly viable, as different components of a 
program may be developed using different approaches
-Combination can be used to make the most efficient, low costing, high quality 
solution
Use of CASE tools
-Computer aided software engineering
-Use of computer assisted method to organise and control development of software, 
especially on large complex projects
-Using CASE allows designers, code writers, testers, planners and managers to share a 
common view of where a project stands at each stage of development
-CASE tool may portray progress graphically and may be linked to the documentation
-Supports specific tasks in software development lifecycle:
oBusiness and Analysis modelling
oDevelopment – design and construction
oVerification and validation – analyse code and specifications for accuracy
oConfiguration management – control check in and out of repository objects
oMetrics and measurement – analyse code for complexity, modularity, 
performance
oProject management - manage project plans, task assignments, scheduling
-Another common way to distinguish CASE tools is the distinction between Upper 
CASE and Lower CASE
oUpper – support business and analysis modelling, they support traditional 
diagrammatic languages such as ER diagrams, Data Flow diagram, structure 
charts, decision trees, decision tables
oLower – support development activities such as physical design, debugging, 
construction, testing, component integration, maintenance and reverse 
engineering
-CASE tools are used in following stages
oSoftware version control – as software is improved it becomes more difficult to 
keep track of versions (1.0, 2.0)
oTest data generation 
Test correct operation of modules
Test and evaluate performance
Check error messages
Outputs can be compared
oProduction of documentation
Avoid delays in production
Data flow diagrams
Structure diagrams
Flow charts
oProduction of code
Methods of installation of new or updated systems
Typically there involves a conversion from an old system to the new system. There are four 
typically methods of installation or conversion:
1. Parallel conversion
2. Pilot conversion
3. Phased conversion
4. Direct cut over
Direct Cut-Over 
-Involves the old system being completely dropped and new system being installed at 
the same time
-Need to make sure the new system is completely functional and operational
-This conversion method is only used when it is not feasible to operate two separate 
systems at the same time
-Any data conversion and import must be done before installation occurs
-New data lost if new system fails
-Implementation occurs over shorter period but may be more time consuming
Parallel 
-Involve the operating of both systems being run for a period of tome
-Allows problems with new system to be found without loss of data
-Once new system is up and running, the old system can stop being used
-Old systems must be used until conversion
Phased
-Gradual introduction of the new and discarding of the old
-Done by introducing new parts while removing old parts
-Often used when product is still under development
-Over time
Pilot
-New system installed for small number of users
-User learn use and evaluate new system
-Once it seen as satisfactory it is installed and used by all
-Allows users to become experts and teacher of the new system
-Pilot conversion also allows for testing of product in an operational setting
Employment trends in software development
-Large increase 1995  2000, employment continues to grow, albeit slower pace
-Employment based on experience
-Meet demand of jobs
-Outsourcing 
oOutsource work to specialists if they do not have expertise or resources
oTo reduce and control costs
oHigher quality results from specialists
oAccess to new tech 
oFaster development times
oSpecialists respond to change
-Contract programmers
oShort term to write specific software products
oCommon for analysts and programmers to change employers as they seek new 
contracts
Trends in software development
-Mobile application
-Big data processing – data analysts
-Cloud technology – iCloud, drop box; cloud security
-DevOPs software – development operation managers – serve customer and clients 
better; cloud management
-User interface developers- consumer focused, intuitive, create enterprise applications
and apps make it user friendly
-Web based software – google apps, Facebook, YouTube Instagram
-Learning objects
-Widgets
-Cloud computing
-Mobile tech
Defining and Understanding the Problem
Identifying the problem
-Carried out by a system analyst
-Includes following aspects
oNeeds of the client
Functionality
Compatibility
Performance
oDetermining the objectives which will be met
oBoundaries and scope of the problem is understood
-Understanding the problem will enable a better understanding of the inputs, 
processing and outputs of the system to be developed
Needs of the client
A need is an instance in which a necessity or want exists. In software development, a 
solution to meet those needs is usually sought. Through discussion and consultation of the 
needs, a set of requirements are developed to inform the development process. Tools to 
analyse the requirements such as:
-Surveys – info for large groups; limited in detail
-Interviews – freedom to discuss in detail; limited to smaller set of people and time 
consuming
-Time management studies and observations – involves observing people processing 
tasks
-Business analysis – examines business rules and tasks
Objectives
-Short term and long-term aim and plans
-Clarification of objectives leads to determining the requirements, boundaries and 
rules for the development. 
-Measurable outcomes are also expressed in objectives
Requirements
-Statements that are indicators of what needs to be met
-The final evaluation of a project’s success or failure is based on how well the original 
requirements have been achieved
Functionality Requirements
-What the system will do and what it needs to achieve
-Give direction to the project
-Requirements are defined as features, properties and behaviours a system must have 
to achieve its purpose
-Functionality requirements may be expressed in terms of measurable standards
-Non-functionality requirements are requirements which impose constraints on design
or implementation
Compatibility Issues
-Software of various types runs on a variety of environments including: OS, browser, 
hardware and screen resolution.
-Environments can be varied by the user
-Software developers must ensure products are able to be used on multiple systems or
devices and conditions
-Compatibility issues include:
oProblems with different OS versions
oIncompatible hardware such as graphics controllers
oDifferent screen size and resolutions
oBrowsers and different HTML standards
oHardware and drivers not supporting software
oIncompatible LAN hardware and drivers
Performance Issues
-Testing and real-world application performance may be very different
-Testing must be extremely thorough and broad but within boundaries
-Issues include:
oAppearing to not be responding when time takes too long
oPoor response times in networking operations
oScreen refresh time lag
oMemory management issues
oCPU processing and process requests
Boundaries of the problem
-Define the limits of the problem 
-Anything outside the system is said to be part of the environment
-System connects with the environment through an interface
Issues relevant to a proposed solution
Determining if an existing solution can be used
-Social and ethical considerations
-Consideration of existing software products
-Customisation of those existing software solutions
-Cost effectiveness
-Licensing considerations
Social and ethical
-Changing nature of work for users
oNew skills to be acquired
-Effects on levels of employment
oTechnology replacing work done by humans
oCreated new information technology jobs
oLess costs for businesses
-Effects on the public
oLarge software systems can have substantial effect on general public e.g. ATM’s
oOlder generation unwilling to accept technological innovation
 Legal issue including license considerations
-Issues relating to copyright
-Software that is used to store and access sensitive information will need to include 
safeguards against unauthorised access
Customisation of existing software products
-Cost effective strategy for obtaining new functionality
-Many software developers spend much of their time modifying their own existing 
products to suit specific needs of individual clients
-Open source software is often customised to add new features; in many cases the 
modifications are built as add-ons which are then available to other users of the base 
software product
-The ability to customise software helps the original developer of the product widen 
their market
-It is common for tools to be included in many commercial products which allows the 
user to create customised screens and other functionality using wizards and multiple 
drag and drop design screens.
Cost effectiveness
-One of the constraints of a new software system will be that it falls within a certain 
budget. If it is not a requirement, then it will most likely be a constraint
-Compare the costs between developing a new product or modifying an existing 
product
-Development hardware costs
oAny new hardware that needs to be bought/leased to enable development
-Development software costs
oWhat software is required; programming languages, CASE tools, database 
managements systems, graphics tools
-Development personnel costs
oSalaries of development team and other staff
-Outsourcing costs
A budget for the development project needs to be decided about a range of factors 
including:
-Available capital
-Predicted sales of finished product
-Cost savings as a result of the products implementation
-Predicted future upgrade and maintenance costs for the product
-Ongoing consumer support costs
Selecting appropriate development approach
-Selecting an appropriate development approach if there is no appropriate existing 
solution is completed by understanding the requirements and specifications of the 
problem
-The nature and type of problem will also affect the development approach and 
programming paradigm to be used.
Design Specifications
Specifications of proposed system
-A software requirements specification is a standard framework for a team to develop 
a large, complex software system and includes a complete description of the 
behaviour of a system to be developed. 
-Includes a set of use cases that describes all the interactions the users will have with 
the software.
-SRS also contains non-functional requirements, and the methods which will be used 
to model the system will also be specified. 
Developers perspective
-Data types 
-Data structures and variables
oVariables represent storage locations of data within the computer system
oA programmer will look at the data items and determine how they are to be 
stored and accessed
oThe data type and an appropriate identifier is then determined
oMeaningful variable names are considered intrinsic documentation and help 
programmers follow the logic of the program
oGlobal or Local Variables
-Algorithms
oPseudocode or flow charts
oProblem is modularised
oTop down decomposition
oFamiliar modules which can be drawn from a library of code
oThis method ensures a minimum of testing is required
-Quality assurance
-Documentation
-Design approach
Users Perspective
-Interface design
-Social and ethical issues
-Relevance to user’s environment and computer configuration
Specifications developed from the user’s point of view should include and design 
specifications that influence the experience of the end user.
Standards for interface design will be specified to ensure continuity of design across the 
project’s screens. The wording of messages, design of icons and the format of any data 
presented to the user need to be determined and a set of specifications created.
- Ergonomic Issues should also be considered
-User’s existing computer environment will influence specifications created.
oIf users are familiar with existing applications, then some design elements 
should be incorporated in new solution so transfer of skills can take place
-Operating system settings and consideration of hardware necessary to execute new 
development
oModels will assist in determining user-based specifications
oCommunication and feedback to and from users is especially important during 
the early stage
System Documentation
Representing a system using systems modelling tools
-Different types of documentation are produced throughout the software 
development cycle
-Many large companies utilise diagrams that form part of the UML (unified modelling 
language) which incorporated a variety of different modelling tools that are now 
available as part of many CASE tools and IDE’s (integrated development 
environments)
-A model of a system is a representation of that system designed to show the 
structure and functionality of a system. Many system modelling tools are in the form 
of diagrams
-The model gives directions and specifications for the developers
-Different types of modelling are applicable to different aspects of the system
IPO Diagrams
-Explain how inputs are transformed into
outputs by processing
-Expand on the processes found in the
data flow diagram and structure
diagram
-IPO diagram can either be
diagrammatical or table form
Context Diagrams
-Used to present an overview of the whole system
-Shown as a single process along with the inputs and outputs
-Attempt to show the data entering and information exiting the system without 
detailing the processing required in any detail.
- The squares are referred to as external entities. 
-Connected to single process by data flow arrows
-Elements are labelled
-Does not show data stores nor internal processes
-Context diagrams are referred to as level 0 data flow diagrams
-Helpful with understanding how system interfaces with the environment
-Process: a circle
-Arrow – flow of data
-External entity/rectangle – person or organisation, source or sink that provides or 
receives data
Data Flow Diagrams
-Represent a system as several process that together form a single system
-Refinement of a context diagram
-Show a further level of detail not shown in context diagrams
-DFD’s identify source of data, flow between processes and it’s destination along with 
data generated by the system
-4 symbols:
oSquares – representing external entities, sources or destinations of data
oCircles – processes, which take data as input, process it, and output it
oArrows- represent the data flow, electronic data or physical items
oOpen ended rectangles – represent data stores such as databases
Storyboards
-Shows the various interfaces in a system as well as the links between them
-The representation of each 
interface should be detailed enough 
for the reader to identify the 
purpose, contents and design 
elements. 
-Areas used for input output and 
navigation should clearly be
identified and labelled
-Any links shown between interfaces 
should originate from the 
navigational element that 
triggers the link.-Software that is used to store and access sensitive information will need to include 
safeguards against unauthorised access
Customisation of existing software products
-Cost effective strategy for obtaining new functionality
-Many software developers spend much of their time modifying their own existing 
products to suit specific needs of individual clients
-Open source software is often customised to add new features; in many cases the 
modifications are built as add-ons which are then available to other users of the base 
software product
-The ability to customise software helps the original developer of the product widen 
their market
-It is common for tools to be included in many commercial products which allows the 
user to create customised screens and other functionality using wizards and multiple 
drag and drop design screens.
Cost effectiveness
-One of the constraints of a new software system will be that it falls within a certain 
budget. If it is not a requirement, then it will most likely be a constraint
-Compare the costs between developing a new product or modifying an existing 
product
-Development hardware costs
oAny new hardware that needs to be bought/leased to enable development
-Development software costs
oWhat software is required; programming languages, CASE tools, database 
managements systems, graphics tools
-Development personnel costs
oSalaries of development team and other staff
-Outsourcing costs
A budget for the development project needs to be decided about a range of factors 
including:
-Available capital
-Predicted sales of finished product
-Cost savings as a result of the products implementation
-Predicted future upgrade and maintenance costs for the product
-Ongoing consumer support costs
Selecting appropriate development approach
-Selecting an appropriate development approach if there is no appropriate existing 
solution is completed by understanding the requirements and specifications of the 
problem
Parameters
-Components of functions
-Identify values that are passed into a function
-Passed from mainline to sub-program
Standard Algorithms
-Linear search
-Finding maximum or minimum values
-Binary search
-Insertion sort
-Selection sort
-Bubble sort
-Processing strings (extracting, deleting and inserting)
-Generating set of unique random numbers
-Processing of sequential and relative files
Arrays
-Structured data type
-Collection of like data
-Data is held in a cell with an index
-Cells are linear in structure
-Array has a name or label
-Arrays hold a single data type
-You can nominate the size of an array
-You do not need to fill all cells in an array
Declaring an Array
-Array is declared before values can be added
-E.g. Declare Array (1-5) as type string
Accessing an Array
-To find (access) the third data element in the ‘array’ = array (3)
-Will return third index value
-To assign a simple variable a value from an array: myarray = array (2)
Sentinel Value
-Used to mark the end of a data list
-EOF – end of file
-Indicates last entry of fata in the structure, so processing can cease
Linear Search
-Examining one item at a time in an array beginning at the first item and moving to the
end of the array
-Does not require numbers to be sorted
-Processing taken for the search is directly related to the size of the array searched
-Linear search involves:
oThe function accepting a search value
oTraverses the array using iteration
oChecks each value compared with search value
oReturns ‘number found’ and the index of cell which value equals search value
oOtherwise returns ‘number not found’
Find Maximum or Minimum
-The value in the first element is stored in a temporary variable called Max/Min
-As the array is traversed each element is considered to determine if its value is 
larger/smaller than that stored value
-If so, the value in Max/Min is replaced by this larger/smaller value, and the index of 
this element is stored in a temporary variable called MAX/Minindex
-When all elements have been considered, Max will contain largest value and 
MaxIndex will contain the index of the largest element and vice versa for minimum
BEGIN FindMAX 
Max = Numbers (0) 
MaxIndex = 0
i = 1 
REPEAT 
IF Numbers (i) > Max THEN 
Max = Element (i) 
MaxIndex = i 
END IF 
i = i + 1 
UNTIL i > NumElementsInArray 
Display “The highest value is ” Max “ at position ” MaxIndex 
END FindMAX
BEGIN FindMIN 
Min = Element (0) 
MinIndex = 0
 i = 1 
REPEAT 
IF Element (i) < Min THEN 
Min = Element (i) 
MinIndex = i 
END IF 
i = i + 1 
UNTIL i > NumElementsinArray 
Display “The smallest value is ” Min “ at position ” MinIndex 
END FindMIN
Binary Search
-Only used if the values in the array are already sorted in order
-The binary search starts by checking the middle value of an array to see if it matches 
the search value
-If not, the binary search then determines if the search value is in the first half of the 
array or the second half (after the middle value)
-This process is repeated with the remaining list of items
-Eventually the required item will be found or the list of possible items will be empty
        Return “Number not found”
       END
Insertion Sort
-Used when a large part of the data is already sorted
-During each pass the last element from the unsorted part is inserted into the 
appropriate place in the sorted part of the array
-A linear search is conducted to find the correct place to insert
-As each sorted element is checked it is moved to the left/right to make room for the 
new elements
-At each pass the sorted section of the array increases by 1
-Process continues until the unsorted section = 0
Selection Sort
-During each pass a linear search is performed
-A marker is placed at the first cell in the array and then search through the array from
that position onwards looking for the smallest value
-When the smallest value is found, it is swapped with the marker’s cell value. This 
naturally places the smallest value at the front of the array
-The next step is to increment the marker to the next cell and repeat the process. 
When the marker reaches the last cell, the array is sorted.
-procedure selection sort 
-   list  : array of items
-   n     : size of list
-
-   for i = 1 to n - 1
-   /* set current element as minimum*/
-      min = i    
-  
-      /* check the element to be minimum */
-
-      for j = i+1 to n 
-         if list[j] < list[min] then
-            min = j;
-         end if
-      end for
-
-      /* swap the minimum element with the current 
element*/
-      if indexMin != i  then
-         swap list[min] and list[i]
-      end if
-   end for
-
-end procedure
swap procedure would include temp value
Bubble Sort
-popular amongst novice programmers
-main logical structure is based on traversing an array and switching adjacent pairs of 
values that are not in the correct order
-after one travers the largest value will have ‘bubbled’ to the end of the array. This is 
repeated until all values are in the correct cells 
BEGIN bubbleSort with numbers 
Index = PositionToInsert
 Counter = 0 
WHILE Counter <= NewStringLength 
OriginalString[Index] = NewString[Counter] 
Increment Index 
Increment Counter
 ENDWHILE 
RETURN Index 
END InsertNewString 
BEGIN ReplaceOriginal(Index, TempStringLength) 
‘Attach end of original string back onto the string’ 
Counter = 0 
WHILE Counter <= TempStringLength
 OriginalString[Index] = TempString[Counter] 
Increment Index
 Increment Counter 
ENDWHILE 
END ReplaceOriginal
Deleting
BEGIN DeleteString(StartPosition, NoOfCharactersToDelete) 
Index = StartPosition 
OriginalStringLength = StringLength(OriginalString) 
WHILE Index <= OriginalStringLength - noOfCharactersToDelete 
‘Overwrites elements to be deleted
 OriginalString[Index] = OriginalString[Index + NoOfCharactersToDelete] 
Increment Index 
ENDWHILE 
WHILE Index <= OriginalStringLength 
OriginalString[Index] = “” 
‘Clear contents of these elements 
Increment Index 
ENDWHILE 
‘The original str string will now be NoOfCharacters Shorter
 END DeleteString
Generating set of unique random numbers
-most high-level languages have a function to generate a random integer or floating-
point number
-generally, a range in the random function is specified
-random number generators have applications in gambling, statistical sampling, 
computer simulation, cryptography
-the generation of pseudo random numbers is an important and common task in 
computer programming
-different applications require different amounts of unpredictability
-most computer-generated random numbers use Pseudo random number generators 
(PRNGs) which are algorithms that can automatically create long runs of numbers 
with random properties but eventually the sequence repeats
-the series of values generated by such algorithms is generally determined by a fixed 
number called a seed
-one if the most common PRNG is the linear congruential generator which uses the 
recurrence:
X n + 1 = ( a X n + b ) mod m {\displaystyle X_{n+1}=(aX_{n}+b)\,{\textrm {mod}}\,m} X_{n+1}
= (a X_n + b)\, \textrm{mod}\, m to generate numbers, where a, b and m are large integers, 
and X n + 1 {\displaystyle X_{n+1}} X_{{n+1}} is the next in X as a series of pseudo-random 
numbers. The maximum number of numbers the formula can produce is the modulus, m.
-processing a set of unique and random numbers requires
oan array to store the numbers
oa loop to generate each number
oand random generator function
oadding to final array of numbers
oa check to see if the number is unique
BEGIN randArray(min, max, num) 
FOR I = 0 to max – min 
rNum(i) = I + min 
NEXT i FOR I = 0 to num – 1 
R = random integer from I to (max – min) inclusive 
Arr(i) = rNum(r) 
rNum(r) = rNum(i) 
NEXT i 
RETURN arr 
END
The VB Rnd function returns a value less than 1, but greater than or equal to zero. The value
of Number determines how Rnd generates a random number. For any given initial seed, the 
same number sequence is generated because each successive call to the Rnd function uses 
the previously generated number as a seed for the next number in the sequence. Before 
calling Rnd, use the Randomize statement without an argument to initialize the random-
number generator with a seed based on the system timer. 
In VB a random number function using Rnd(): randomVa lue = CInt(Math.Floor((upperbound
- lowerbound + 1) * Rnd())) + lowerbound
Processing of sequential files
-the data stored in a sequential file is stored in a continuous string
-the data is accessed from beginning to end
-text files are sequential files
-sentinel files are used to indicate the end of a file
-once sequential files are read and the sentinel is reached, files are closed
Priming read
-the statement which reads the first input data record prior to starting a structured 
loop
-the main purpose of a priming read is to allows the processing block that follows it to 
be structured
Open for input, output or append
Sequential files can be opened in one of three modes:
1. Input – used to read the data within a file
2. Output – used to write data to a new file
3. Append – used to write data at the end of an existing file
Processing of relative files
-Relative refers to the position of a record in the file as each record is the same length
-Allows the relative position of a record to be known
-The position of each record in the file is used as a key to allows direct access of a 
record (instead of sequential)
-Relative files are used to store records
-Each record is the same data type and length
-Fields are usually padded out with blank characters
Retrieving, writing and updating a record in a relative file
-Relative files need to be open for relative access to be updated and must be closed 
before the program ends
-All records are accessed using a key which specifies the relative position of that 
record within the file.
-The key fields used must contain positive integer values only
-E.g. follow algorithm allows the price of any product to be changed:
 Dog
Interface Design in software Solutions
-Designs of screen will be influenced by the nature of the problem.
Consideration of the intended audience
Each screen in a program will have a target audience. If the screen is to be effective, the 
needs of that audience must be met:
-Organisation of screen elements
-The way they are presented
-The way the user interacts with the interface and the way help is provided
Communication with the user is key to finding out the specifications for interface design 
depending on the target audience.
Identification of screen size
-Screen size will be affected by the intended hardware the software will be installed on
-Will also impact screen resolutions and graphics hardware and drivers
Identification of data fields and screen elements
-Screens are designed to present data, input data or output data
-It is important for the developer to have a clear understanding of how data items 
need to be presented to the user
-The context in which data is displayed is closely related to the processes being carried
out.
oMenus are used to initiate executions of modules within a program
oCommand buttons are used to select a different path for execution, often used 
for confirmations
oTool bars; used to quickly access commonly used items
oText boxes; receive input in the form of strings
oList boxes; force the user to select from the given options
oCombinations boxes; combine functions of text box and list box
oCheck boxes; obtain Boolean input from the user
oOptions or radio buttons; select from one of the displayed options
oScroll bars; navigation
oGrid; likened to an array of records
oLabels; provide guidance and information to the user
oPicture/image box; display graphics
Online help and user feedback
-Help system should be designed to encourage user to seek assistance immediately a 
problem is encountered
-Context sensitive help
oIf user asks for help, new window displayed containing information about 
user’s last action
oSmall windows can open to display simple tips relating to current screen 
elements if the user holds the mouse over an element for more than a few 
seconds
-Procedural help
oConcise and accurate instructions on how to complete a specific task
o‘how’ rather than ‘why’
-Conceptual help
oAims to explain ‘what’ and ‘why’ rather than ‘how’
oTours, tutorials and wizards
Consistency in Approach
-Must be consistency between screens within an application
-Allows the user to anticipate actions and placement
-Design rules should be created before the development process is undertaken
oEspecially important when a team of programmers is employed
-Transfer across to new product
-Aspects of consistency
oNames of commands
oUse of icons
oPlacement of screen elements
oFeedback
oForgiveness 
Customised off the shelf packages
-Identifying an appropriate package
oCost benefit analysis; if a package will take more time and effort rather than to 
build a new application from scratch it is not worth modifying
-Identifying the changes that need to be made
-Obtaining permission from original author
-Identifying how the changes are to be made
Standard modules and library routines
Reasons for development and use of standard modules
-Consideration of local and global variables
oLocal variables can only be used within their own module/subprogram
oGlobal variables can be accessed throughout the whole program
oScope: refers to the amount of the program in which the variable can be used
-Appropriate use of parameters
Identification of appropriate modules or subroutine
-Thorough documentation including intrinsic naming of variables and objects
-Standard control structures are utilised
-Choice of language suits the module
-Social and ethical issues related to the modules
-Modules that contain redundant tasks will only waste memory
Appropriate testing using drivers
-Drivers are temporary code used to test the execution of a module when the module 
cannot function individually without a mainline     
Recognition of relevant social and ethical issues
-Ease of use
-Accessibility of technical language
-Copyright
-Ergonomics
Factors considered when choosing a language
Sequential or event driven software
-Sequential
oScreens follow one after the other and minimum user input is required
oData items are accessed from outside of the program
-Event-driven
oData items are accessed from within the program and the user controls the 
order of processing, creates an interactive and dynamic pattern to follow
Driven by user or programmer
-User
oProgram logic
oRequires user’s actions to trigger an event
oFeatures menus, buttons, icons etc.
oOrder of module execution is defined by the user
oPolling: process of continuously checking the status of events
oEvent parsing: executes events that the user has instigated
oUsed in computer games
-Programmer
oSequential approach
oFollows set of steps to solve a given problem
oUtilises standard control structures such as Begin… End, Do… Until
oOrder of module execution is defined by the programmer
oUsed in data handling programs such as databases and word processers
Other
-Hardware requirements
-Is GUI required
-Experience of the developers
Features requires and available in the language
-Commands within the language to interface with the required hardware
-Ability to run under different operating systems
Factors considered for use of technology
Performance requirements
-Minimum hardware configuration
oProcessor type and speed
oPrimary storage (RAM) available
oSpecific input and output devices
oSecondary storage size and type
oA minimum operating system
-Requirements either come from purpose of the software, others from the system 
being used to convert the source code into executable code
Benchmarking
-Involves creating a set of tasks that can be used to measure the speed with which a 
computer system will perform a task
-Allows for a comparison between different combinations of hardware and software
-Purely objective process and so subjective measurements of aspects such as user 
friendliness and ergonomic factors are not included in the process
-Interpreting these results are just as important as obtaining them.
Implementation of software solutions
Language syntax required for software solutions
Railroad diagram
-Alternative graphical method used to define the syntax of a programming language
-Rectangles are used to enclose non-terminal symbols, that is, symbols that will be 
further defined
-Circles or rounded rectangles are used to enclose terminal symbols
-Linked by paths to show all valid combinations
-By starting at the left-hand side of the diagram and tracing any path in a forward 
direction to reach the right-hand side of the diagram, a syntactically correct construct 
is defined
Extended Backus-Naur Forms (EBNF)
-Symbols:
o<...> represents a defined element (non-terminal symbol)
o| represents an alternative
o: = represents a statement is defined
o{…} represents repeated elements
o[…] represents optional elements
o(…) represents grouped elements
Metalanguage descriptions of programming languages
Declaring multi-dimensional arrays and arrays of records
In general, declaring a variable for use within a program involves two stages. Firstly, if the 
data type or structure does not already exist in the language then it must be defined. 
Secondly, a variable of the required type is declared.
Translation methods in software solutions
-High level languages cannot be directly understood by a processor. Instructions must 
be converted into binary. Source code  machine executable code
-Source code is said to be machine independent; can be used on several different 
processors.
-Executable code is very processor specific, each different family of processors will 
have different machine language instructions
Compilation
-Takes source code and produces a complete translated file
-Compiling is machine CPU specific
-This file can be used on other machines with same CPU without a need for translator
-Batch process
-Unwanted code, such as comments/remarks, are removed therefore creating code 
that is more efficient
-Allows for use of share resource and libraries
-Each time a change is made, the whole program must be recompiled
-Slower testing and error detection phase
-All coding errors are reported at the end
Interpretation
-Translation but slower, less efficient object code as each line is translated when 
loaded into memory
-Line by line translation and execution
-Much slower overall executions
-Errors reported line by line; instant error feedback
-Early error detection of runtime errors
-When error is detected, execution is halted
-Users must have the interpreter on their computer
Incremental compilation
-Compiles each line of source code and adds it to object file
-Line by line translation
-Errors reported instantly
-Result is still a compiled object file
Compilation Interpretation
Advantages Runs faster and more efficient
Source code is private
Cross platform
Easier debugging
Disadvantages Executables created with compilers
are machine specific; not cross 
platform
If it is to operate on a different 
processor/operating system, 
source code must be recompiled, 
longer to develop in
Slows down execution significantly 
because of each statement needing
to be translated before it is 
executed
Public source
Users of interpreted programs must
have copy of the interpreter
Compilation process in detailSign in
Register
Download
Save
Cyber Safety
Cyber safety is about minimising the risks of cyber dangers, particularly children. While 
security software and firewalls attempt to protect the user, it is necessary for self-protection
methods to be utilised should the user wish to remain safe. Government initiative 
(cybersmart.gov) informs users about cyber safe practices and procedures:
-Location-based services
-Unwanted contact
-Cyberbullying
-Online friends
-Your digital footprint
-Online purchasing
-Identity theft
Evaluating information through the internet
Due to the unregulated nature of the Internet, massive amount of information is available – 
often without a stated author. This leads to concerns regarding the credibility of the 
information. These questions should be asked to evaluate a source:
-Who is the author?
-Is the information up to date?
-Who is intended audience?
-Is information accurate and unbiased?
-What is the purpose of the information?
Rights and Responsibilities of software developer
Software developers and users have rights and responsibilities including:
-The right to good quality software for users
-The right to protection for the software creators
-Responsibility to develop and use software in a social and legally ethical manner.
Software developers invest time and money into the development of their products. 
Investment brings responsibilities to the developer but also gives them rights over the 
product they develop.
Electronic material is easy to reproduce and distribute but not easy to develop.
Intellectual property 
There is often ambiguity on who is the ‘creator of the software’ as:
-Software product is developed in a coding language, which was developed by another
company
-A team of developers is utilised to create software, often outsources
-Modules of source code can be purchased from third party,
-Artwork and images are created in a graphic design company
Software developers need to acknowledge all the ‘creators’ and ensure all compensation is 
paid.
Quality
Quality assurance is used to ensure standard of quality are being met by software 
developers. It is often difficult for software developers to maintain high quality due to 
financial/time constraints. Customer’s perceive quality through their expectations. Involves 
correctness, reliability, efficiency, integrity, useability, maintainability, flexibility, testability, 
portability, interoperability.
External factors affecting quality include hardware, operating system, other software and 
run time errors.
Hardware – To ensure maximum reliability of their product, software application developers
should test their product with several different hardware configurations
Operating system- software products should interface correctly with specifications of 
operating system. Software should also be forward compatible as OS is always being 
updated
Other software – software should not adversely react to each other to create unwanted 
results
Run-time errors – All applications developed should include error checking built into the 
code. Developers must include routines that will deal with possible errors in execution. For 
example, developer would include save procedure when detecting a fatal error.
Response to problems
Mechanisms are needed to assist in the identification of errors and their resolution, such as 
support departments and severity classifications
Code of Conduct
Set of standards by which software developers agree to abide. These standards increase the
quality of developed software across the industry. Can be expelled if not adhering to code 
of conduct.
Malware 
Developers have a responsibility to both do not develop malware and to constantly check 
for malware in their workplace environments. Users have the right to expect their software 
to be free of malware
Ergonomic issues
Determining user needs about their work routine assist in the user interface design which 
allows users to work efficiently including consistency of elements, colour, fonts and 
alignment properly. User testing is used to evaluate the ergonomic design of software.
Inclusivity Issues
Responsibility to ensure software is accessible to anyone regardless of their differences 
including cultural differences, economic market, gender and disability.
Privacy
Users have the right to know if their information is being held. Some organisations need to 
legitimately access sensitive information and therefore users are protected under the 
Privacy Act 1988.
Software Piracy and Copyright
Illegal copying and use of software. Occurs when intellectual property rights of the 
developer are infringed. Software piracy results in the increase in the cost of software for 
those who follow ethical standards and reduce user options as software developers have 
reduced incentive to develop new ideas.
Intellectual property is personal ownership of the creative ideas that develop from an 
individual’s mind or intellect. Includes patents, trademarks, trade secrets and confidential 
business information.
Plagiarism is appropriating or imitating someone’s ideas and manner of expressing them 
and claiming them as your own. Plagiarism in software is ambiguous and to avoid infringing 
another person’s intellectual property and sources should be acknowledged and 
compensated.
Copyright Laws
Purpose of these laws is to provide economic incentives for creative activity. Copyright 
protects the expression of ideas rather than the ideas themselves. They give the owner the 
sole right to reproduce their own work. Copyright Amendment Act 2006. Lasts for 70 years.
Classification of software
Commercial
-Purchasing licence to use software
-Licensing company owns product and copyright
-Software covered by copyright
-One archival copy can be made
-Reverse engineering and de-compilation not allowed
Open Source
-Available to all to modify and redistribute, modified products must be released 
through same unrestricted open source licence. Encourages collaboration and sharing
of ideas.
Shareware
-Covered by copyright
-Distributed for trial use before purchase
-User must pay to continue to use software after trial period
Public Domain
-Freely available for copying and modification
-Copyright has finished
Reverse Engineering is the process of reading source code and translating it into an 
algorithm. The algorithm can then be modified and recoded in the same or another 
programming language. Reverse engineering is legal when the program is owned by the 
developer carrying out the reverse engineering however it is illegal is someone else does.
De-compilation is the process of translating object code (machine code) into code that is 
more easily studied by a programmer.
Software Licences
-Enforced by law
-Protects developer’s ownership of the software that they have created
-Licence conditions – determine what can be done with software, many developers 
include a compulsory reading and acceptance of the EULA before installing can 
continue.
-Licence – formal permission or authority to use a product
-Agreement – mutual agreement or contract between parties
-Term – period the agreement is in force
-Warranty – assurance of some sort, a guarantee
-Limited use – restricted use of product
-Liability – an obligation or debt because of some sort of consequence
-Program – refers to computer software
Ownership versus licensing – purchasing media that contains computer software does not 
mean you own the software; you have been sold the right to use the software under certain 
conditions verified in your licence.
Current and emerging technologies used to combat software
-Non copiable datasheet
-Disc copy protection
-Hardware serial numbers – if software and hardware do not match, program will not 
run
-Site license installation counter on a network
-Registration code for software
-Encryption keys to scramble/unscramble data/ software
-Back to base authentication
Use of Networks
Software developers have recognised the increasing popularity of networked computers. 
Programs are now available for network use. They could be either a) centralised software in 
which software is available as a single copy on a central server or b) distributed software 
which is available on individual machines. Regardless, each machine on the network or 
using the software requires a separate license.
Use of networks by software developer
Access to resources – graphical assets, source code, third party libraries
Ease of communication – networks allow developers to communicate with each other
Productivity – collaboration can effectively increase productivity due to both the ease of 
communication and access to resources
Use of networks by user
Response times – important for users and will usually give up if too slow. Factors such as 
server load are out of the hands of the developers and is an effect of networking
Interface design – Interface design can improve or ease response times. If interfaces are 
designed in such a way that the program provides a visual response even if it has not 
received a networking response, a user is more likely to continue use of the program
Privacy and security issues – Often sensitive data is transferred across networks. Precautions
are often made to ensure that the data remains private.
The Software Market
The aim of a developer is to maintain their space in the software market.
To market a software product the following needs to be considered:
Product
-The expectation of customers should be met by product
-It is unethical to produce a product that does not meet the user’s expectations.
-Also includes custom software, where software is designed specifically for a business
Place
-An audience must be specified before deciding on a place to sell the product
-There are many methods of distributing software; shop fronts, online, bookstores.
-Depending on where the software is sold, it can change the perception of customer’s 
expectations
Price
-A developer has a responsibility to arrange a reasonable price for a product
-Methods for pricing a product are either a cost-plus basis, or consumer-based pricing
Promotion
-The different ways developers use to persuade people to buy products
-Developers have an ethical responsibility in what they say about their product to their
consumers
-Promotion should help customers make informed choices
-Information cannot be misleading
-Word of mouth is a very powerful promotional tool for software.
Impact of new developers and software products
New software breakthroughs are usually inventions of new thinking and therefore boom. 
New products will pop up to try and innovate against the existing product, but unless it 
provides a huge advantage, the consumer is more likely to stick with the original default 
software product.
Legal Implications
National Legal Action
RACV vs Unisys 
Claims management system  electronic storage and retrieval system
Failed expectations of software. RACV sought damages citing false representation and 
misleading conduct. Awarded damages of $4 million dollars to RACV  
Microsoft vs Apple
Microsoft released windows after Apple released Macintosh. Both systems were distributed 
before legal action was taken. A settlement was reached allowing both companies to 
distribute their OS.
 Software Development Approaches
Factors of defining approaches
-Scale of the product
-Complexity of the product
-Skills of the personnel developing the product
-Detail of the requirements
-Time for project
-Budget
5 software approaches:
-Structured
-Agile
-Rapid application development
-Prototyping
-End user
Each software development approach consists of the same stages continually repeated, but 
with the frequency and timing unique to each development cycle.
5 stages include:
-Defining and understanding the problem
-Planning and designing
-Implementation
-Testing and evaluating
-Maintenance
Structured Approach
-Time consuming, ordered and controlled
-Highest level of personnel skill required
-Product of highest size and quality
-Top down approach (waterfall method)
-Thoroughly planned, documented and monitored
-Used for large products in large companies
-Costs are high and errors can be hard to find and correct
-Requirements are understood before design and coding occurs
-Requires high project management
Agile Approach
-Emerged due to demand for products to be specifically tailored for individuals
-Places emphasis on system being developed
-In depth documentation is not needed
-Focus on team-work, cooperating, communication skills and efficient work methods
-Development team must be able to adapt to situation
-Small teams preferred; members are multiskilled
-Characterized by speed of getting to user, interaction between team and users, 
responds well to changing circumstances
-Product in development being continually updated
Prototyping approach
-Lies between structured and agile approach
-Predates the agile approach 
-Repeatedly iterates through development stages to refine user requirements
-Each prototype includes more functionality
-Intense user interaction
-Prototypes are just interactive models of the user interface
-Favoured over structured approach if ability to adapt to changing requirements is 
required
Two types of prototyping
- Concept prototyping
oInspire discussion and thought about product
oPrototype will never be final product
oUsed to develop requirements and discarded after evaluation 
- Evolutionary Prototyping
oPrototype ends up being final product
oEach successive generation of prototype is an improvement
Some software developers take this further, by considering the maintenance stage of the 
cycle as part of the designing and understanding stage of the next cycle of development
Acknowledges that the communication with users is very important and helps in the 
defining and understanding of any future products to be developed.
Rapid Application Development
-Main purpose of reducing time and money
-Result of low quality, less usability and less features. 
-RAD has only become possible due to 4th generation languages which enable visual 
production of interfaces with little coding taking place in the background
-Ability to include re-usable code which has been developed
-Integrate with other software solutions
-Development team to work very close to each other
-Continuous feedback with users
-Only meets most important requirements
-RAD lacks formal stages to reduce time and cost
-Removes need for data structures, algorithms 
-Uses existing routines and API of applications
-RAD is suited when
oDistribution is narrow
oApplication runs on small LAN
oDoes not need to interface with other software systems
-Advantages of RAD
oReduced coding of modules where library code is used
oLess errors 
oLibrary code can ensure consistent look and feel
oShorter development cycle
End User 
-never used in software companies, not made for purpose of making money
-used to address a specific problem that end user needs a solution for
-very small budget
-does not require knowledge of workings of a computer, as it uses Customised off the 
shelf (COTS), Wizards or other automated code generating devices.
-Resulting programs will not be overly complex and may not meet specifications that 
the user may have initially wanted
-Advantages of End User approach
oThe solution can be revised and modified at will, without consultation with 
other users
oNo money required
oLess development time required
oA freedom to change requirements at any stage
Combinations of Software Development Approaches
-Does not have to be of one type or another
-Combinations of approaches are perfectly viable, as different components of a 
program may be developed using different approaches
-Combination can be used to make the most efficient, low costing, high quality 
solution
Use of CASE tools
-Computer aided software engineering
-Use of computer assisted method to organise and control development of software, 
especially on large complex projects
-Using CASE allows designers, code writers, testers, planners and managers to share a 
common view of where a project stands at each stage of development
-CASE tool may portray progress graphically and may be linked to the documentation
-Supports specific tasks in software development lifecycle:
oBusiness and Analysis modelling
oDevelopment – design and construction
oVerification and validation – analyse code and specifications for accuracy
oConfiguration management – control check in and out of repository objects
oMetrics and measurement – analyse code for complexity, modularity, 
performance
oProject management - manage project plans, task assignments, scheduling
-Another common way to distinguish CASE tools is the distinction between Upper 
CASE and Lower CASE
oUpper – support business and analysis modelling, they support traditional 
diagrammatic languages such as ER diagrams, Data Flow diagram, structure 
charts, decision trees, decision tables
oLower – support development activities such as physical design, debugging, 
construction, testing, component integration, maintenance and reverse 
engineering
-CASE tools are used in following stages
oSoftware version control – as software is improved it becomes more difficult to 
keep track of versions (1.0, 2.0)
oTest data generation 
Test correct operation of modules
Test and evaluate performance
Check error messages
Outputs can be compared
oProduction of documentation
Avoid delays in production
Data flow diagrams
Structure diagrams
Flow charts
oProduction of code
Methods of installation of new or updated systems
Typically there involves a conversion from an old system to the new system. There are four 
typically methods of installation or conversion:
1. Parallel conversion
2. Pilot conversion
3. Phased conversion
4. Direct cut over
Direct Cut-Over 
-Involves the old system being completely dropped and new system being installed at 
the same time
-Need to make sure the new system is completely functional and operational
-This conversion method is only used when it is not feasible to operate two separate 
systems at the same time
-Any data conversion and import must be done before installation occurs
-New data lost if new system fails
-Implementation occurs over shorter period but may be more time consuming
Parallel 
-Involve the operating of both systems being run for a period of tome
-Allows problems with new system to be found without loss of data
-Once new system is up and running, the old system can stop being used
-Old systems must be used until conversion
Phased
-Gradual introduction of the new and discarding of the old
-Done by introducing new parts while removing old parts
-Often used when product is still under development
-Over time
Pilot
-New system installed for small number of users
-User learn use and evaluate new system
-Once it seen as satisfactory it is installed and used by all
-Allows users to become experts and teacher of the new system
-Pilot conversion also allows for testing of product in an operational setting
Employment trends in software development
-Large increase 1995  2000, employment continues to grow, albeit slower pace
-Employment based on experience
-Meet demand of jobs
-Outsourcing 
oOutsource work to specialists if they do not have expertise or resources
oTo reduce and control costs
oHigher quality results from specialists
oAccess to new tech 
oFaster development times
oSpecialists respond to change
-Contract programmers
oShort term to write specific software products
oCommon for analysts and programmers to change employers as they seek new 
contracts
Trends in software development
-Mobile application
-Big data processing – data analysts
-Cloud technology – iCloud, drop box; cloud security
-DevOPs software – development operation managers – serve customer and clients 
better; cloud management
-User interface developers- consumer focused, intuitive, create enterprise applications
and apps make it user friendly
-Web based software – google apps, Facebook, YouTube Instagram
-Learning objects
-Widgets
-Cloud computing
-Mobile tech
Defining and Understanding the Problem
Identifying the problem
-Carried out by a system analyst
-Includes following aspects
oNeeds of the client
Functionality
Compatibility
Performance
oDetermining the objectives which will be met
oBoundaries and scope of the problem is understood
-Understanding the problem will enable a better understanding of the inputs, 
processing and outputs of the system to be developed
Needs of the client
A need is an instance in which a necessity or want exists. In software development, a 
solution to meet those needs is usually sought. Through discussion and consultation of the 
needs, a set of requirements are developed to inform the development process. Tools to 
analyse the requirements such as:
-Surveys – info for large groups; limited in detail
-Interviews – freedom to discuss in detail; limited to smaller set of people and time 
consuming
-Time management studies and observations – involves observing people processing 
tasks
-Business analysis – examines business rules and tasks
Objectives
-Short term and long-term aim and plans
-Clarification of objectives leads to determining the requirements, boundaries and 
rules for the development. 
-Measurable outcomes are also expressed in objectives
Requirements
-Statements that are indicators of what needs to be met
-The final evaluation of a project’s success or failure is based on how well the original 
requirements have been achieved
Functionality Requirements
-What the system will do and what it needs to achieve
-Give direction to the project
-Requirements are defined as features, properties and behaviours a system must have 
to achieve its purpose
-Functionality requirements may be expressed in terms of measurable standards
-Non-functionality requirements are requirements which impose constraints on design
or implementation
Compatibility Issues
-Software of various types runs on a variety of environments including: OS, browser, 
hardware and screen resolution.
-Environments can be varied by the user
-Software developers must ensure products are able to be used on multiple systems or
devices and conditions
-Compatibility issues include:
oProblems with different OS versions
oIncompatible hardware such as graphics controllers
oDifferent screen size and resolutions
oBrowsers and different HTML standards
oHardware and drivers not supporting software
oIncompatible LAN hardware and drivers
Performance Issues
-Testing and real-world application performance may be very different
-Testing must be extremely thorough and broad but within boundaries
-Issues include:
oAppearing to not be responding when time takes too long
oPoor response times in networking operations
oScreen refresh time lag
oMemory management issues
oCPU processing and process requests
Boundaries of the problem
-Define the limits of the problem 
-Anything outside the system is said to be part of the environment
-System connects with the environment through an interface
Issues relevant to a proposed solution
Determining if an existing solution can be used
-Social and ethical considerations
-Consideration of existing software products
-Customisation of those existing software solutions
-Cost effectiveness
-Licensing considerations
Social and ethical
-Changing nature of work for users
oNew skills to be acquired
-Effects on levels of employment
oTechnology replacing work done by humans
oCreated new information technology jobs
oLess costs for businesses
-Effects on the public
oLarge software systems can have substantial effect on general public e.g. ATM’s
oOlder generation unwilling to accept technological innovation
 Legal issue including license considerations
-Issues relating to copyright
-Software that is used to store and access sensitive information will need to include 
safeguards against unauthorised access
Customisation of existing software products
-Cost effective strategy for obtaining new functionality
-Many software developers spend much of their time modifying their own existing 
products to suit specific needs of individual clients
-Open source software is often customised to add new features; in many cases the 
modifications are built as add-ons which are then available to other users of the base 
software product
-The ability to customise software helps the original developer of the product widen 
their market
-It is common for tools to be included in many commercial products which allows the 
user to create customised screens and other functionality using wizards and multiple 
drag and drop design screens.
Cost effectiveness
-One of the constraints of a new software system will be that it falls within a certain 
budget. If it is not a requirement, then it will most likely be a constraint
-Compare the costs between developing a new product or modifying an existing 
product
-Development hardware costs
oAny new hardware that needs to be bought/leased to enable development
-Development software costs
oWhat software is required; programming languages, CASE tools, database 
managements systems, graphics tools
-Development personnel costs
oSalaries of development team and other staff
-Outsourcing costs
A budget for the development project needs to be decided about a range of factors 
including:
-Available capital
-Predicted sales of finished product
-Cost savings as a result of the products implementation
-Predicted future upgrade and maintenance costs for the product
-Ongoing consumer support costs
Selecting appropriate development approach
-Selecting an appropriate development approach if there is no appropriate existing 
solution is completed by understanding the requirements and specifications of the 
problem
-The nature and type of problem will also affect the development approach and 
programming paradigm to be used.
Design Specifications
Specifications of proposed system
-A software requirements specification is a standard framework for a team to develop 
a large, complex software system and includes a complete description of the 
behaviour of a system to be developed. 
-Includes a set of use cases that describes all the interactions the users will have with 
the software.
-SRS also contains non-functional requirements, and the methods which will be used 
to model the system will also be specified. 
Developers perspective
-Data types 
-Data structures and variables
oVariables represent storage locations of data within the computer system
oA programmer will look at the data items and determine how they are to be 
stored and accessed
oThe data type and an appropriate identifier is then determined
oMeaningful variable names are considered intrinsic documentation and help 
programmers follow the logic of the program
oGlobal or Local Variables
-Algorithms
oPseudocode or flow charts
oProblem is modularised
oTop down decomposition
oFamiliar modules which can be drawn from a library of code
oThis method ensures a minimum of testing is required
-Quality assurance
-Documentation
-Design approach
Users Perspective
-Interface design
-Social and ethical issues
-Relevance to user’s environment and computer configuration
Specifications developed from the user’s point of view should include and design 
specifications that influence the experience of the end user.
Standards for interface design will be specified to ensure continuity of design across the 
project’s screens. The wording of messages, design of icons and the format of any data 
presented to the user need to be determined and a set of specifications created.
- Ergonomic Issues should also be considered
-User’s existing computer environment will influence specifications created.
oIf users are familiar with existing applications, then some design elements 
should be incorporated in new solution so transfer of skills can take place
-Operating system settings and consideration of hardware necessary to execute new 
development
oModels will assist in determining user-based specifications
oCommunication and feedback to and from users is especially important during 
the early stage
System Documentation
Representing a system using systems modelling tools
-Different types of documentation are produced throughout the software 
development cycle
-Many large companies utilise diagrams that form part of the UML (unified modelling 
language) which incorporated a variety of different modelling tools that are now 
available as part of many CASE tools and IDE’s (integrated development 
environments)
-A model of a system is a representation of that system designed to show the 
structure and functionality of a system. Many system modelling tools are in the form 
of diagrams
-The model gives directions and specifications for the developers
-Different types of modelling are applicable to different aspects of the system
IPO Diagrams
-Explain how inputs are transformed into
outputs by processing
-Expand on the processes found in the
data flow diagram and structure
diagram
-IPO diagram can either be
diagrammatical or table form
Context Diagrams
-Used to present an overview of the whole system
-Shown as a single process along with the inputs and outputs
-Attempt to show the data entering and information exiting the system without 
detailing the processing required in any detail.
- The squares are referred to as external entities. 
-Connected to single process by data flow arrows
-Elements are labelled
-Does not show data stores nor internal processes
-Context diagrams are referred to as level 0 data flow diagrams
-Helpful with understanding how system interfaces with the environment
-Process: a circle
-Arrow – flow of data
-External entity/rectangle – person or organisation, source or sink that provides or 
receives data
Data Flow Diagrams
-Represent a system as several process that together form a single system
-Refinement of a context diagram
-Show a further level of detail not shown in context diagrams
-DFD’s identify source of data, flow between processes and it’s destination along with 
data generated by the system
-4 symbols:
oSquares – representing external entities, sources or destinations of data
oCircles – processes, which take data as input, process it, and output it
oArrows- represent the data flow, electronic data or physical items
oOpen ended rectangles – represent data stores such as databases
Storyboards
-Shows the various interfaces in a system as well as the links between them
-The representation of each 
interface should be detailed enough 
for the reader to identify the 
purpose, contents and design 
elements. 
-Areas used for input output and 
navigation should clearly be
identified and labelled
-Any links shown between interfaces 
should originate from the 
navigational element that 
triggers the link.
Structure Charts
-Describe the top down design and sequence of processing
-Represent a system by showing the separate modules or subroutines that 
compromise the system and their relationship to each other
-Chart is read from top to bottom, with component modules or subroutines on 
successively lower levels, indicating these models or subroutines are called by the 
module or subroutine above.
-Modules are read left to right to show the order of execution
-These modules set the structure for the development of the IPO diagrams and then 
the development of the algorithm and subsequent coding of each module
-Structure charts are useful for maintenance 
-Symbols used
oOpen arrow – data movement between modules or subroutines, usually passes
as parameters
oClosed arrow – indicate a flag or control variable
oSmall diamond at intersection – a decision
oUndo arrow – repetition
oLine – call the module
System Flowcharts
-Used to represent the logic and
movement of data between the
system components, including
hardware, software and manual
components
-System flowcharts are a
diagrammatic way of representing
the system to show the flow of
data, the separate modules
comprising the system and the
media used
-Many symbols for system flowcharts have become outdated because of changes in 
technology
-Symbols:
Data dictionaries
-Comprehensive description of each data item in a system
-Commonly includes:
oVariable name
oSize in bytes
oNumber of characters as displayed on screen
oData type
oFormat including decimal points if applicable
oDescription
oExample
Algorithms used to document the logic in modules and 
subroutines
-The logic in modules and subroutines are represented before coding using 
pseudocode and Flowcharting
-Pseudocode uses English-like statements with defined rules of structure and 
keywords
-Flowchart is a graphical representation
-Flowcharts should not be used for large projects
Test data and expected output
-Many operational factors may be outside the control of the programmer, or unable to
be foreseen (e.g. inputs, variation in hardware, different OS and changing 
technologies)
-Programmer can only test the program within the bounds that are set during the 
analysis stage of development
-With an increasing size of an application it makes it harder to create test data to run 
throughout the whole application
-Modularisation of programs means that data can be created to test each module 
however it is also likely that an unforeseen output from one module will cause 
problems in other modules in the program
Communication issues between client and developer
Need to consult with the client
-Implementation of a new system is generally easier if stakeholders feel that they have
contributed to the development
-Many conflicts can be avoided if good communication is carried out between the 
developers and the users
-Developers are familiar with the technical aspects of the development of a new 
system
-The users are familiar with the operation of the current system and can provide good 
feedback and screen design operation and training requirements
-Good communication is achieved by:
oempowering the user
oacknowledging the user’s knowledge and perspective
oenabling and accepting feedback 
The need to incorporate the client’s perspective
-the developer and user are equally important to the success of the software project, 
and the developer must accept the expertise of the user and use it to better 
understand the system
-user perspective should be considered while designing both the processes and the 
interfaces
The need for the developer to enable and consider feedback
-for effective communication, developers need to establish both formal and informal 
channels and communication
-formal channels
omemos and regular meeting to keep the users up to date with the 
development process
-informal channels
odiscussed at any time during development process, as quite often matters will 
arise that cannot be kept until the next formal meeting
-user should have the opportunity to provide feedback
-development process will proceed well if members can achieve constructive criticism 
and if there is two-way communication
The need to involve and empower the client during the 
development process
-changing work practices are often cause for discomfort, resentment and fear
-people who are going to be affected by a software change will more readily accept 
them and if they feel that they have had input into the design process and will have a 
sense of ownership of the product
-ownership is especially important after installation, as users are more likely to 
describe problems or suggest enhancements
-empowering the user also means giving them the ability to make decisions that affect
their work
Quality Assurance
Refers to the planned and systematic activities implemented in a quality system so that 
quality requirements for a product or service will be fulfilled.
-Quality assurance involves:
othe need to define the criteria on which the quality of the product will be 
judged and may include requirements
oputting in place management processes to ensure that quality criteria is being 
met
oan ongoing QA process to ensure quality criteria is being met
-A set or list of measurable criteria is required
-The criteria to judge the quality of the project is considered and set early
-SQA ensures that software will function reliably as intended and is free of errors
-Includes:
oEfficiency – best use of computer’s resources
oIntegrity – correctness of data within the system
oReliability – ability of the system to continue to perform its functions over time
oUsability – ability of software to be learned and used by new users
oAccuracy – software performs its functions correctly and according to 
specifications
Can only be assured when code has been thoroughly tested
oMaintainability – measure of ease with change to software
oTestability – individual modules and subroutines should be able to and have 
been thoroughly tested and system should be tested to ensure it performs 
according to requirements
oRe-usability – ability to reuse code in other related systems
Programmers maintain a library of subroutines and modules that 
perform commonly used functions to ensure quicker and error free 
coding
Planning and Designing Software Solutions
Identification of appropriate modules
-Algorithms are usually written by designing modules and then the sub-modules
-This design process is called a ‘top-down design’ and is the most popular way to solve
problems with structured programs 
-Top down design is where the main module is written followed by the sub-
modules/functions it calls
Inputs, Outputs and Processes
-IPO charts look at the processing of data
-Also address the management of data; where it comes from, how we store it, how it 
is used in processing and its format or type for output
Consideration of global and local variables
-Consideration of global and local variables should be done in the design stage
-Local variables are only used in the module which they are declared
-Any modules can access global variables
Scope of variables
-Where the variables are declared/created/used
-Scope describes where in the algorithm the variable can be used
Parameters
-Components of functions
-Identify values that are passed into a function
-Passed from mainline to sub-program
Standard Algorithms
-Linear search
-Finding maximum or minimum values
-Binary search
-Insertion sort
-Selection sort
-Bubble sort
-Processing strings (extracting, deleting and inserting)
-Generating set of unique random numbers
-Processing of sequential and relative files
Arrays
-Structured data type
-Collection of like data
-Data is held in a cell with an index
-Cells are linear in structure
-Array has a name or label
-Arrays hold a single data type
-You can nominate the size of an array
-You do not need to fill all cells in an array
Declaring an Array
-Array is declared before values can be added
-E.g. Declare Array (1-5) as type string
Accessing an Array
-To find (access) the third data element in the ‘array’ = array (3)
-Will return third index value
-To assign a simple variable a value from an array: myarray = array (2)
Sentinel Value
-Used to mark the end of a data list
-EOF – end of file
-Indicates last entry of fata in the structure, so processing can cease
Linear Search
-Examining one item at a time in an array beginning at the first item and moving to the
end of the array
-Does not require numbers to be sorted
-Processing taken for the search is directly related to the size of the array searched
-Linear search involves:
oThe function accepting a search value
oTraverses the array using iteration
oChecks each value compared with search value
oReturns ‘number found’ and the index of cell which value equals search value
oOtherwise returns ‘number not found’
Find Maximum or Minimum
-The value in the first element is stored in a temporary variable called Max/Min
-As the array is traversed each element is considered to determine if its value is 
larger/smaller than that stored value
-If so, the value in Max/Min is replaced by this larger/smaller value, and the index of 
this element is stored in a temporary variable called MAX/Minindex
-When all elements have been considered, Max will contain largest value and 
MaxIndex will contain the index of the largest element and vice versa for minimum
BEGIN FindMAX 
Max = Numbers (0) 
MaxIndex = 0
i = 1 
REPEAT 
IF Numbers (i) > Max THEN 
Max = Element (i) 
MaxIndex = i 
END IF 
i = i + 1 
UNTIL i > NumElementsInArray 
Display “The highest value is ” Max “ at position ” MaxIndex 
END FindMAX
BEGIN FindMIN 
Min = Element (0) 
MinIndex = 0
 i = 1 
REPEAT 
IF Element (i) < Min THEN 
Min = Element (i) 
MinIndex = i 
END IF 
i = i + 1 
UNTIL i > NumElementsinArray 
Display “The smallest value is ” Min “ at position ” MinIndex 
END FindMIN
Binary Search
-Only used if the values in the array are already sorted in order
-The binary search starts by checking the middle value of an array to see if it matches 
the search value
-If not, the binary search then determines if the search value is in the first half of the 
array or the second half (after the middle value)
-This process is repeated with the remaining list of items
-Eventually the required item will be found or the list of possible items will be empty
        Return “Number not found”
       END
Insertion Sort
-Used when a large part of the data is already sorted
-During each pass the last element from the unsorted part is inserted into the 
appropriate place in the sorted part of the array
-A linear search is conducted to find the correct place to insert
-As each sorted element is checked it is moved to the left/right to make room for the 
new elements
-At each pass the sorted section of the array increases by 1
-Process continues until the unsorted section = 0
Selection Sort
-During each pass a linear search is performed
-A marker is placed at the first cell in the array and then search through the array from
that position onwards looking for the smallest value
-When the smallest value is found, it is swapped with the marker’s cell value. This 
naturally places the smallest value at the front of the array
-The next step is to increment the marker to the next cell and repeat the process. 
When the marker reaches the last cell, the array is sorted.
-procedure selection sort 
-   list  : array of items
-   n     : size of list
-
-   for i = 1 to n - 1
-   /* set current element as minimum*/
-      min = i    
-  
-      /* check the element to be minimum */
-
-      for j = i+1 to n 
-         if list[j] < list[min] then
-            min = j;
-         end if
-      end for
-
-      /* swap the minimum element with the current 
element*/
-      if indexMin != i  then
-         swap list[min] and list[i]
-      end if
-   end for
-
-end procedure
swap procedure would include temp value
Bubble Sort
-popular amongst novice programmers
-main logical structure is based on traversing an array and switching adjacent pairs of 
values that are not in the correct order
-after one travers the largest value will have ‘bubbled’ to the end of the array. This is 
repeated until all values are in the correct cells 
BEGIN bubbleSort with numbers 
Set index to first index of numbers +1 
WHILE index <= last index of numbers 
IF numbers[index –1] > numbers[index] THEN 
Swap(numbers[index –1] and numbers[index]) 
ENDIF
 Increment index 
ENDWHILE 
END
Processing Strings
-string – string of characters one after another forming a sequence
String Concepts
-in traditional systems strings were not identified directly in a programming language
-a programmer had to work with the individual characters that make up a message or 
word
-a string was represented as an array of character
-commonly given a default value of 256 characters
-common operations include
odetermining the length of the string
ojoining strings together – concatenation
oextracting characters from the string
oinserting characters into the string
odeleting characters
Determining length of string
BEGIN StringLength(String) 
Index = 0 
WHILE String[Index] contains a character 
Increment Index 
ENDWHILE 
Length = Index
 RETURN Length 
END StringLength
Extracting 
BEGIN ExtractString(StartPosition, NoOfCharactersToExtract) 
Index = StartPosition 
Counter = 0 
Set NewString() to an empty array of characters 
WHILE Counter <= NoOfCharactersToExtract 
NewString[Counter] = OriginalString[Index] 
Increment Index 
Increment Counter 
ENDWHILE 
RETURN NewString 
END ExtractString
Inserting
BEGIN InsertString(NewString, PositionToInsert)
  ‘Calculate Length of original and new strings’ 
OriginalStringLength = StringLength(OriginalString) 
NewStringLength = StringLength(NewString) 
TempStringLength = 0 
Index = 0 
ExtractOriginal(PositionToInsert, OriginalStringLength) 
InsertNewString(PositionToInsert, NewStringLength) 
ReplaceOriginal(Index, TempStringLength) 
END InsertString 
BEGIN ExtractOriginal(PositionToInsert, OriginalStringLength)
 ‘Create a copy of the end of the original string’ 
Index = PositionToInsert 
Counter = 0 
Set TempString() to an empty array of characters 
WHILE Index <= OriginalStringLength 
TempString[Counter] = OriginalString[Index] 
Increment Index 
Increment Counter
 ENDWHILE TempStringLength = Index 
RETURN TempStringLength 
END ExtractOriginal 
BEGIN InsertNewString(PositionToInsert, NewStringLength) 
‘Insert new string’ 
Index = PositionToInsert
 Counter = 0 
WHILE Counter <= NewStringLength 
OriginalString[Index] = NewString[Counter] 
Increment Index 
Increment Counter
 ENDWHILE 
RETURN Index 
END InsertNewString 
BEGIN ReplaceOriginal(Index, TempStringLength) 
‘Attach end of original string back onto the string’ 
Counter = 0 
WHILE Counter <= TempStringLength
 OriginalString[Index] = TempString[Counter] 
Increment Index
 Increment Counter 
ENDWHILE 
END ReplaceOriginal
Deleting
BEGIN DeleteString(StartPosition, NoOfCharactersToDelete) 
Index = StartPosition 
OriginalStringLength = StringLength(OriginalString) 
WHILE Index <= OriginalStringLength - noOfCharactersToDelete 
‘Overwrites elements to be deleted
 OriginalString[Index] = OriginalString[Index + NoOfCharactersToDelete] 
Increment Index 
ENDWHILE 
WHILE Index <= OriginalStringLength 
OriginalString[Index] = “” 
Company
About Us
StuDocu World University Ranking 2021
Doing Good
Academic Integrity
Jobs
Dutch Website
Contact & Help
Frequently Asked Questions
Contact
Legal
Terms
Privacy Policy
Cookie Statement
Social
Facebook
Twitter
Instagram
YouTube
TikTok
Blog
Get the App
Copyright © 2021 StudeerSnel B.V., Keizersgracht 424, 1016 GC Amsterdam, KVK: 56829787, BTW: NL852321363B01
out of 74Download
We use cookies in order to improve your experience. By continuing, you agree to the use of cookies and other technologies by us and our trusted partners to process personal data.
Accept